# Types

Electurm.jl provides a rich type system for handling a variety of data that may arise in 
computational work with crystalline materials. Many of these types are generic enough to handle 
cases of crystals in arbitrary dimension, which may be useful for theoretical work or for handling
complicated real-world cases, such as incommensurately modulated crystals.

# Lattices and basis vectors

## Basis vectors

The `AbstractBasis` type contains two subtypes, `RealBasis` and `ReciprocalBasis`, which can be
used to represent the basis vectors of a crystal.

`AbstractBasis` types use the following conventions:
  * The units are assumed to be angstroms or inverse angstroms.
  * Conversion between the two involve a factor of 2Ï€ (multiplication for the `RealBasis` >  
`ReciprocalBasis` conversion, and vice versa).

### Why not use `SMatrix` for basis vectors?

While the `SMatrix` type seems to make sense for a collection of basis vectors, it poses one major 
problem: the calculation of type parameters.

The `SMatrix{D1,D2,T,L}` type requires four type parameters - `D1` and `D2` are each of the matrix
dimensions, and `T` is the element type of the matrix. However, one last parameter is needed: `L`, 
the length of the `NTuple` that backs the `SMatrix`.

Julia currently does not allow for the calculation of type parameters from other type parameters,
which poses a serious problem in the declaration of structs. Technically, a type like
`SMatrix{3,3,Float64}` is an abstract type, as the `L` parameter is undeclared, even though the 
value of `L` can be inferred from `D1` and `D2`. By declaring a struct to have this type, there
seems to be a significant performance drop.

The `AbstractBasis{D}` types wrap an `SVector{D,SVector{D,Float64}}`. This only requires a single 
type parameter `D`, and allows for fully concrete struct declarations. Various methods are defined
on this type to make it work like a normal matrix, such as matrix multiplication.

The other issue is that there are contexts where real space basis vectors are easier to use and
others where reciprocal basis vectors are easier to use. It's better to treat them as two
interconvertible types for that reason.

# Real and reciprocal lattices

Electrum.jl provides real and reciprocal lattices as their own types: `RealLattice` and 
`ReciprocalLattice`. Both of these are instances of `AbstractLattice`, and they may be freely
converted between each other.

`AbstractLattice` types consist of pairs of `BasisVectors`, a primitive set of basis vectors which
may be accessed with `prim()` and a conventional set of basis vectors which may be accessed with
`conv()`.

## Crystals

The `AbstractCrystal` supertype contains two concrete types, `Crystal{D}` and 
`CrystalWithDatasets{D,K,V}`. The `CrystalWithDatasets` type is a combination of a `Crystal{D}`
with a `Dict{K,V}`. 

### `Crystal`

The `Crystal` data type consists of five pieces of information:
  * A real space lattice (`latt::RealLattice{D}`)
  * The space group number (`sgno::Int`)
  * The offset of the space group origin from the cell origin (`orig::SVector{D,Float64}`)
  * The generating set of atomic positions (`gen::AtomList{D}`)
  * The explicitly included set of atomic positions, or template (`pos::AtomList{D}`)

There are two sets of atomic positions included: `gen` contains all of the atomic positions needed
to describe the unit cell, and `pos` contains explicitly generated sites. The positions in `pos` 
can be used to select sites to write to a file or display in a plot.

Currently, Electrum.jl does not deal with space group information, so the inclusion of a space
group number or origin offset does not have any effect internally. In the future, we may be able to
use this information to reduce the number of atomic positions stored in `gen` to the minimum
generating set of atoms.

### `CrystalWithDatasets`

`CrystalWithDatasets{D,K,V}` is a struct that pairs a `Crystal{D}` with a `Dict{K,V}`.
`CrystalWithDatasets` objects generated by Electrum.jl will almost always have `K` be a `String`.

You can access datasets with `getindex()`, so a `CrystalWithDatasets` behaves similarly to a 
dictionary. It should be noted that autocompletion is not currently supported for
`CrystalWithDatasets`, and due to how Julia REPL functionality is implemented, adding this
functionality may not be possible for the foreseeable future.

# Datasets

Electrum.jl supports a good number of different data types, including:
  * Real space datagrids
  * Reciprocal space data by HKL index
  * Band structures and densities of states
  * k-point lists and grids
  * Data by atomic position
  * Spherical harmonic coefficients

## Real space datagrids

Real space data is usually represented with a `RealSpaceDatagrid{D,T}`, which consists of the
following:
  * The basis vectors that define the unit cell which is described by the data 
(`latt::BasisVectors{D}`)
  * The shift of the data grid off of the unit cell origin (`orig::SVector{D,Float64}`)
  * The grid of data values (`grid::Array{T,D}`)

### Mathematical operations on `RealSpaceDataGrid`

Supported unary mathematical operations on a `RealSpaceDataGrid` are negation (`-`) and the fast 
Fourier transform (`FFTW.fft()`).

Binary operations, however, need checks to ensure that two grids are compatible with each other.
"Compatible" means:
  * The datagrids are of the same spatial dimension.
  * The basis vectors of both grids are identical.
  * The shifts of both grids are identical.
  * The number of elements along each dimension are identical.

Failure to meet any of these criteria will result in an `AssertionError` being thrown. The internal
function `Electrum.grid_check()` performs these checks and is called before binary operations are 
performed.

In the future, we may relax the third requirement by using interpolation, though a warning will be
thrown if this is invoked.
