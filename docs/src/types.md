# Types

Electrum.jl provides a rich type system for handling a variety of data that may arise in 
computational work with periodic structures. Many of these types are generic enough to handle cases
of crystals in arbitrary dimension, which may be useful for theoretical work or for handling
complicated real-world cases, such as incommensurately modulated crystals.

# Atoms

## `NamedAtom`

The `NamedAtom` type stores two pieces of information - an atomic number and a name for the atom.
Only the atomic number or an atomic symbol (given as an `AbstractString`) is required to name the
atom, but both pieces of information can be provided.

Dummy atoms can be created by constructing a `NamedAtom` with a name that is not an atomic symbol
or an atomic number of zero. These are useful for marking important positions in a unit cell.

## `CartesianAtomPosition` and `FractionalAtomPosition`

These types are combinations of a `NamedAtom` and an `SVector`. A `CartesianAtomPosition` describes
an atomic coordinate in the default length units (bohr), and a `FractionalAtomPosition` describes
an atomic coordinate with respect to a crystal lattice basis, which is not included with the
coordinate.

## `AtomList` and `PeriodicAtomList`

These wrap `Vector{CartesianAtomPosition{D}}` and `Vector{FractionalAtomPosition{D}}`, respectively.
A `PeriodicAtomList` describes atomic positions in a lattice, and thus includes a `RealBasis{D}`. 

## Crystals

The `AbstractCrystal` supertype contains two concrete types, `Crystal{D}` and 
`CrystalWithDatasets{D,K,V}`. The `CrystalWithDatasets` type is a combination of a `Crystal{D}`
with a `Dict{K,V}`. 

### `Crystal`

The `Crystal` data type consists of four pieces of information:
  * A list of atoms with a basis (`atoms::PeriodicAtomList{D}`)
  * The space group number (`sgno::Int`)
  * The offset of the space group origin from the cell origin (`sgorig::SVector{D,Float64}`)
  * An integer linear transformation that describes a supercell (`transform::SMatrix{D,D,Float64}`)

Currently, Electrum.jl does not deal with space group information, so the inclusion of a space
group number or origin offset does not have any effect internally. In the future, we may be able to
use this information to reduce the number of atomic positions stored in `atoms` to the minimum
needed to generate all atoms in the unit cell.

The linear transformation included with a `Crystal` is the identity matrix by default, but this can
be changed using `set_transform!()`. This can be used with a crystal defined with a primitive
lattice to lazily reference its conventional cell. 

### `CrystalWithDatasets`

`CrystalWithDatasets{D,K,V}` is a struct that pairs a `Crystal{D}` with a `Dict{K,V}`.
`CrystalWithDatasets` objects generated by Electrum.jl will almost always have `K` be a `String`.

Datasets may be accessed with `getindex()`, so a `CrystalWithDatasets` behaves similarly to a 
dictionary. It should be noted that autocompletion is not currently supported for
`CrystalWithDatasets`, and due to how Julia REPL functionality is implemented, adding this
functionality may not be possible for the foreseeable future.

# Datasets

Electrum.jl supports a good number of different data types, including:
  * Real space datagrids
  * Reciprocal space data by HKL index
  * Band structures and densities of states
  * k-point lists and grids
  * Data by atomic position
  * Spherical harmonic coefficients

## Data traits

Electrum.jl uses a trait system to classify its types that are used to store non-structural crystal
data. These are subtypes of `Electrum.CrystalDataTrait` and include `Electrum.ByRealSpace{D}`,
`Electrum.ByReciprocalSpace{D}`, and `Electrum.ByAtom`, which correspond to data in D-dimensional
real space, data in D-dimensional reciprocal space, and data associated with individual atoms,
respectively.

To recover the data space trait, `DataSpace()` may be called with either the object or object type.
For custom types, this may be overloaded.

The `RealBasis{D}` and `ReciprocalBasis{D}` types return `ByRealSpace{D}()` and
`ByReciprocalSpace{D}()`, respectively. By default, types that have a defined `basis()` function
(or, by extension, a field `basis::Electrum.LatticeBasis`) will derive the trait from the return
type of `basis()`.

## `DataGrid`, `RealDataGrid`, and `ReciprocalDataGrid`

An `DataGrid{D,B<:Electrum.LatticeBasis,S<:AbstractVector{<:Real},T}` contains data defined in a
crystal lattice of `D` with basis vectors of type `B`, a shift parameter of type `S`, and elements
of type `T`, either in real space (`RealDataGrid`) or in reciprocal space (`ReciprocalDataGrid`).
These aliases are defined as follows:

```julia
const RealDataGrid{D,T} = DataGrid{D,RealBasis{D,Float64},SVector{D,Float64},T}
const ReciprocalDataGrid{D,T} = DataGrid{D,ReciprocalBasis{D,Float64},KPoint{D},T}
```
!!! note
    Look closely at the above definition: the shift data type for `RealDataGrid{D}` is
    `SVector{D,Float64}`, but the shift data type for `ReciprocalDataGrid{D}` is `KPoint{D}`. When
    the `DataGrid` constructor without the shift type parameter is invoked, the basis type is used
    to infer the appropriate shift type so that a `RealDataGrid` or `ReciprocalDataGrid` is
    constructed.

`DataGrid` uses zero-based, periodic indexing: the first index of an `AbstractDataGrid{D}` is
`zero(NTuple{D,Int})`, and indices whose moduli with respect to size along that dimension are
identical will reference the same element: for instance, for `g::AbstractDataGrid{3}` with size
`(10, 10, 10)`, `g[69, 420, 1337] === g[9, 0, 7]`. Encountering a `BoundsError` is not possible
when indexing an `DataGrid`.

The basis of an `DataGrid` can be recovered with `basis(::DataGrid)`, which will be of the type
specified by the type parameter. 

### Broadcasting and mathematical operations

Broadcasting is defined for `DataGrid` with a custom `Base.Broadcast.BroadcastStyle` subtype:
```julia
Electrum.DataGridStyle{D,B,S} <: Broadcast.AbstractArrayStyle{D}
```
This allows `DataGrid` instances to operated on with dot syntax. However, they must share lattice
basis vectors and shift values. If they do not match, an `Electrum.LatticeMismatch` exception will
be thrown.

!!! info
    Although `Base.Broadcast.ArrayStyle` is usually overridden by other subtypes of 
    `Base.Broadcast.AbstractArrayStyle`, it does not override `Electrum.DataGridStyle`. Adding a
    `DataGrid` to an `Array` returns an `Array`, and adding a `DataGrid` to other `AbstractArray`
    subtypes returns the `AbstractArray` subtype defined by the `Broadcast.BroadcastStyle`. In the 
    case of a dimension mismatch, the broadcast style wll be `Broadcast.ArrayConflict` - the
    operation will throw a `DimensionMismatch`.

The `+` and `-` operators are defined for `DataGrid` instances, and they are faster than the
broadcasted `.+` and `.-` equivalents. As with the broadcasted versions, checks are implemented to
ensure that the lattice basis vectors and shifts match.

Similarly, the `*`, `/`, and `\` operators are defined for pairs of `DataGrid` and `Number`
instances, and again, are faster than their broadcasted equivalents.

The Fourier transform and its inverse are available through an overload of `FFTW.fft()` and
`FFTW.ifft()`. The transforms are normalized with respect to the basis vectors of the space, so
for `g::DataGrid`, `ifft(fft(g)) â‰ˆ g` (to within floating point error).
