# Types

Electrum.jl provides a rich type system for handling a variety of data that may arise in 
computational work with periodic structures.. Many of these types are generic enough to handle cases
of crystals in arbitrary dimension, which may be useful for theoretical work or for handling
complicated real-world cases, such as incommensurately modulated crystals.

# Lattices and basis vectors

## Basis vectors

The `AbstractBasis` type contains two subtypes, `RealBasis` and `ReciprocalBasis`, which can be
used to represent the basis vectors of a crystal.

`AbstractBasis` types use the following conventions:
  * The units are assumed to be bohr for lengths or rad bohr⁻¹ for inverse.
  * Conversion between the two involve a factor of 2π (multiplication for the `RealBasis` >  
`ReciprocalBasis` conversion, and vice versa).

### Why not use `SMatrix` for basis vectors?

While the `SMatrix` type seems to make sense for a collection of basis vectors, it poses one major 
problem: the calculation of type parameters.

The `SMatrix{D1,D2,T,L}` type requires four type parameters - `D1` and `D2` are each of the matrix
dimensions, and `T` is the element type of the matrix. However, one last parameter is needed: `L`, 
the length of the `NTuple` that backs the `SMatrix`.

Julia currently does not allow for the calculation of type parameters from other type parameters,
which poses a serious problem in the declaration of structs. Technically, a type like
`SMatrix{3,3,Float64}` is an abstract type, as the `L` parameter is undeclared, even though the 
value of `L` can be inferred from `D1` and `D2`. By declaring a struct to have this type, there
seems to be a significant performance drop.

The `AbstractBasis{D}` types wrap an `SVector{D,SVector{D,Float64}}`. This only requires a single 
type parameter `D`, and allows for fully concrete struct declarations. Various methods are defined
on this type to make it work like a normal matrix, such as matrix multiplication.

The other issue is that there are contexts where real space basis vectors are easier to use and
others where reciprocal basis vectors are easier to use. It's better to treat them as two
interconvertible types for that reason.

# Atoms

## `NamedAtom`

The `NamedAtom` type stores two pieces of information - an atomic number and a name for the atom.
Only the atomic number or an atomic symbol (given as an `AbstractString`) is required to name the
atom, but both pieces of information can be provided.

Dummy atoms can be created by constructing a `NamedAtom` with a name that is not an atomic symbol
or an atomic number of zero. These are useful for marking important positions in a unit cell.

## `CartesianAtomPosition` and `FractionalAtomPosition`

These types are combinations of a `NamedAtom` and an `SVector`. A `CartesianAtomPosition` describes
an atomic coordinate in the default length units (bohr), and a `FractionalAtomPosition` describes
an atomic coordinate with respect to a crystal lattice basis, which is not included with the
coordinate.

## `AtomList` and `PeriodicAtomList`

These wrap `Vector{CartesianAtomPosition{D}}` and `Vector{FractionalAtomPosition{D}}`, respectively.
A `PeriodicAtomList` describes atomic positions in a lattice, and thus includes a `RealBasis{D}`. 

## Crystals

The `AbstractCrystal` supertype contains two concrete types, `Crystal{D}` and 
`CrystalWithDatasets{D,K,V}`. The `CrystalWithDatasets` type is a combination of a `Crystal{D}`
with a `Dict{K,V}`. 

### `Crystal`

The `Crystal` data type consists of four pieces of information:
  * A list of atoms with a basis (`atoms::PeriodicAtomList{D}`)
  * The space group number (`sgno::Int`)
  * The offset of the space group origin from the cell origin (`sgorig::SVector{D,Float64}`)
  * An integer linear transformation that describes a supercell (`transform::SMatrix{D,D,Float64}`)

Currently, Electrum.jl does not deal with space group information, so the inclusion of a space
group number or origin offset does not have any effect internally. In the future, we may be able to
use this information to reduce the number of atomic positions stored in `atoms` to the minimum
needed to generate all atoms in the unit cell.

The linear transformation included with a `Crystal` is the identity matrix by default, but this can
be changed using `set_transform!()`. This can be used with a crystal defined with a primitive
lattice to lazily reference its conventional cell. 

### `CrystalWithDatasets`

`CrystalWithDatasets{D,K,V}` is a struct that pairs a `Crystal{D}` with a `Dict{K,V}`.
`CrystalWithDatasets` objects generated by Electrum.jl will almost always have `K` be a `String`.

Datasets may be accessed with `getindex()`, so a `CrystalWithDatasets` behaves similarly to a 
dictionary. It should be noted that autocompletion is not currently supported for
`CrystalWithDatasets`, and due to how Julia REPL functionality is implemented, adding this
functionality may not be possible for the foreseeable future.

# Datasets

Electrum.jl supports a good number of different data types, including:
  * Real space datagrids
  * Reciprocal space data by HKL index
  * Band structures and densities of states
  * k-point lists and grids
  * Data by atomic position
  * Spherical harmonic coefficients

## Data traits

Electrum.jl uses a trait system to classify its types that are used to store non-structural crystal
data. These are subtypes of `Electrum.CrystalDataTrait` and include `Electrum.ByRealSpace()`
`Electrum.ByReciprocalSpace()`, and `Electrum.ByAtom()`, which correspond to data in real space,
data in reciprocal space, and data associated with individual atomic positions, respectively.

To recover the data space trait, `data_space()` may be called with either the object or object type.
For custom types, this may be overloaded.

The `RealBasis` and `ReciprocalBasis` types return `ByRealSpace()` and `ByReciprocalSpace()`,
respectively, and by default, any type with a field named `:basis` will return the data space trait
associated with the type of that field.

## `AbstractDataGrid` and its subtypes

An `AbstractDataGrid{D,T}` contains data defined in a crystal lattice of `D` dimensions containing
elements of type `T`, either in real space (`RealSpaceDataGrid`) or in reciprocal space (`HKLData`).
At minimum, concrete subtypes must contain an `AbstractBasis{D}` and an `Array{T,D}` which contains
the entries.

`AbstractDataGrid` uses zero-based, periodic indexing: the first index of an `AbstractDataGrid{D}`
is `zero(NTuple{D,Int})`, and indices whose moduli with respect to size along that dimension are
identical will reference the same element: for instance, for `g::AbstractDataGrid{3}` with size
`(10, 10, 10)`, `g[69, 420, 1337] === g[9, 0, 7]`. Encountering a `BoundsError` is not possible
when indexing an `AbstractDataGrid`.

The basis of an `AbstractDataGrid` can be recovered with `basis(::AbstractDataGrid)`. If you decide
to subtype `AbstractDataGrid`, note that the method is defined:
```julia
basis(g::AbstractDataGrid) = g.basis
```
The data type for the basis should be `RealBasis` if representing real space data and
`ReciprocalBasis` if representing reciprocal space data, corresponding with the traits mentioned
previously.

## Mathematical operations

Supported unary mathematical operations on a `RealSpaceDataGrid` are negation (`-`) and the fast 
Fourier transform (`FFTW.fft()`/`FFTW.ifft()`).

Binary operations, however, need checks to ensure that two grids are compatible with each other.
"Compatible" means:
  * The datagrids are of the same spatial dimension.
  * The basis vectors of both grids are identical.
  * The shifts of both grids are identical.
  * The number of elements along each dimension are identical.

Failure to meet any of these criteria will result in an `AssertionError` being thrown. The internal
function `Electrum.grid_check()` performs these checks and is called before binary operations are 
performed. This function, in turn, calls `Electrum.grid_specific_check()` which can be overloaded
by the user to perform other tests for custom subtypes of `AbstractDataGrid`. This function should
return `nothing` and throw `AssertionError` when incompatible grids are found.

In the future, we may relax some requirement by using Fourier interpolation, though a warning will
be thrown if this is invoked.
