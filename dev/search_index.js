var documenterSearchIndex = {"docs":
[{"location":"api/filetypes.html#File-types","page":"File formats","title":"File types","text":"","category":"section"},{"location":"api/filetypes.html#Miscellaneous","page":"File formats","title":"Miscellaneous","text":"","category":"section"},{"location":"api/filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readXYZ\nElectrum.readCPcoeff\nElectrum.readCPgeo\nElectrum.readCPcell","category":"page"},{"location":"api/filetypes.html#Electrum.readXYZ","page":"File formats","title":"Electrum.readXYZ","text":"readXYZ(io::IO) -> AtomList{3}\n\nReads an XYZ file into an AtomList{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcoeff","page":"File formats","title":"Electrum.readCPcoeff","text":"readCPcoeff(file, Lmax::Val{L}=Val{6}()) -> SphericalComponents{L}\n\nReads in the spherical harmonic projection coefficients from a CPpackage2 calculation.\n\nBy default, CPpackage2 gives the coefficients for spherical harmonics up to a maximum l value of 6.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPgeo","page":"File formats","title":"Electrum.readCPgeo","text":"readCPgeo(file) -> Vector{AtomPosition{3}}\n\nReads the atomic positions used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcell","page":"File formats","title":"Electrum.readCPcell","text":"readCPcell(file) -> RealBasis{3}\n\nReads the basis vectors of the unit cell used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writeXYZ\nElectrum.writeTOML","category":"page"},{"location":"api/filetypes.html#Electrum.writeXYZ","page":"File formats","title":"Electrum.writeXYZ","text":"writeXYZ(io::IO, data::AbstractVector{<:AbstractAtomPosition})\nwriteXYZ(io::IO, data::AbstractAtomList)\nwriteXYZ(io::IO, data::AbstractCrystal)\n\nWrite an XYZ file based on a set of atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.writeTOML","page":"File formats","title":"Electrum.writeTOML","text":"writeTOML(file, x; sorted=false, by=identity)\n\nWrites x, an Electrum data type, to a file. Currently, x may be either an AbstractAtomList or a Crystal.\n\nThe sorted and by keywords are passed through from TOML.print and allow for sorting of the keys in the file output.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#XCrysDen-XSF-files","page":"File formats","title":"XCrysDen XSF files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-2","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readXSF\nElectrum.readXSF3D","category":"page"},{"location":"api/filetypes.html#Electrum.readXSF","page":"File formats","title":"Electrum.readXSF","text":"readXSF(\n    file;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n) -> CrystalWithDatasets\n\nGeneric function for reading XSF data of arbitrary dimensionality. Currently, only 3D data is supported, as this name is an alias for readXSF3D. This will change in the future.\n\nFor more information, see the documentation for readXSF3D.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readXSF3D","page":"File formats","title":"Electrum.readXSF3D","text":"readXSF3D(\n    file;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n) -> CrystalWithDatasets{3}\n\nReads in an XCrysDen XSF file from an input stream and returns a CrystalWithDatasets{3} with all datasets that have been included within the file. The XSF file must contain 3D crystal data; data of other dimensionalities (such as slab data) will fail.\n\nSpace group and origin information are not supplied in XSF files, but they can be supplied using the spgrp and origin keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing-2","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writeXSF","category":"page"},{"location":"api/filetypes.html#Electrum.writeXSF","page":"File formats","title":"Electrum.writeXSF","text":"writeXSF(io, xtal::PeriodicAtomList{D})\n\nWrites the crystal component of an XCrysDen XSF file.\n\n\n\n\n\nwriteXSF(io::IO, key, data::RealDataGrid{D}; periodic=true)\n\nWrites the crystal component of an XCrysDen XSF file. By default, automatic wrapping of the datagrid occurs (values are repeated at the end of each dimension).\n\n\n\n\n\nwriteXSF(io::IO, xtaldata::CrystalWithDatasets{D,K,V})\n\nWrites a CrystalWithDatasets to an XCrysDen XSF file.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#ABINIT-files","page":"File formats","title":"ABINIT files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-3","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.read_abinit_DEN\nElectrum.read_abinit_POT\nElectrum.read_abinit_WFK","category":"page"},{"location":"api/filetypes.html#Electrum.read_abinit_DEN","page":"File formats","title":"Electrum.read_abinit_DEN","text":"read_abinit_DEN(file)\n    -> CrystalWithDatasets{3,String,RealDataGrid{3,Float64}}\n\nReads a FORTRAN binary formatted abinit density file. By default, abinit density files will have the suffix DEN, but no assumptions are made about suffixes.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin densities.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_POT","page":"File formats","title":"Electrum.read_abinit_POT","text":"read_abinit_POT(file)\n    -> CrystalWithDatasets{3,String,RealDataGrid{3,T<:Number}}\n\nReads a FORTRAN binary formatted abinit potential file.\n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_WFK","page":"File formats","title":"Electrum.read_abinit_WFK","text":"read_abinit_WFK(file; quiet = false)\n    -> CrystalWithDatasets{3,String,PlanewaveWavefunction{3,Complex{Float64}}}\n\nReads a FORTRAN binary formatted abinit wavefunction file.\n\nBy default, abinit returns wavefunction data in Complex{Float64} entries, and this is maintained in the return type.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nBy default, the function is verbose, with output printed for every k-point parsed, due to the large size of the wavefunction files. If this behavior is undesirable, the quiet keyword argument may be set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#VASP-files","page":"File formats","title":"VASP files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-4","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readCONTCAR\nElectrum.readDOSCAR\nElectrum.readPOSCAR\nElectrum.readPROCAR\nElectrum.readWAVECAR\nElectrum.get_fermi","category":"page"},{"location":"api/filetypes.html#Electrum.readCONTCAR","page":"File formats","title":"Electrum.readCONTCAR","text":"readPOSCAR(file) -> PeriodicAtomList{3}\nreadCONTCAR(file) -> PeriodicAtomList{3}\n\nReads a VASP POSCAR or CONTCAR file. A POSCAR contains the basis vectors of the system (potentially given with a scaling factor), the positions of all atoms as either Cartesian or reduced coordinates, and potentially information needed to perform an ab initio MD run (currently ignored). The similarly formatted CONTCAR file is the geometry output generated after a VASP run.\n\nRegardless of whether the coordinates are Cartesian or fractional, this function always returns a  PeriodicAtomList{3}, and the units are converted from angstroms to bohr.\n\nBy default, if the provided file path is a directory, readPOSCAR() will read from a file named POSCAR in that directory. If no argument is provided, a file named POSCAR in the current working directory is read. readCONTCAR() will search for a file named CONTCAR in an analogous manner.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readDOSCAR","page":"File formats","title":"Electrum.readDOSCAR","text":"readDOSCAR(file) -> Tuple{DensityOfStates, Vector{ProjectedDensityOfStates}}\n\nReads a DOSCAR file from VASP and returns its data as a tuple containing the total and projected density of states (if present).\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPOSCAR","page":"File formats","title":"Electrum.readPOSCAR","text":"readPOSCAR(file) -> PeriodicAtomList{3}\nreadCONTCAR(file) -> PeriodicAtomList{3}\n\nReads a VASP POSCAR or CONTCAR file. A POSCAR contains the basis vectors of the system (potentially given with a scaling factor), the positions of all atoms as either Cartesian or reduced coordinates, and potentially information needed to perform an ab initio MD run (currently ignored). The similarly formatted CONTCAR file is the geometry output generated after a VASP run.\n\nRegardless of whether the coordinates are Cartesian or fractional, this function always returns a  PeriodicAtomList{3}, and the units are converted from angstroms to bohr.\n\nBy default, if the provided file path is a directory, readPOSCAR() will read from a file named POSCAR in that directory. If no argument is provided, a file named POSCAR in the current working directory is read. readCONTCAR() will search for a file named CONTCAR in an analogous manner.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPROCAR","page":"File formats","title":"Electrum.readPROCAR","text":"readPROCAR(file) -> FatBands{3}\n\nReads an lm-decomposed PROCAR file from VASP and returns its data as a FatBands{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readWAVECAR","page":"File formats","title":"Electrum.readWAVECAR","text":"readWAVECAR(file) -> PlanewaveWavefunction{3,Complex{Float32}}\n\nReads a WAVECAR file output from a VASP 4.6 calcuation to a PlanewaveWavefunction.\n\nInformation about VASP WAVECAR files and much of the code was adapted from WaveTrans (originally written in FORTRAN): https://www.andrew.cmu.edu/user/feenstra/wavetrans/\n\nThis function is limited to WAVECAR files which have an RTAG value of 45200 (meaning the data is given as a Complex{Float32}) and have only a collinear magnetic field applied, like WaveTrans. It should also be noted that the weights of the k-points are not present in the WAVECAR file, and are set to 1 by default.\n\nBy default, the function is verbose, with output printed for every k-point parsed, due to the large size of the wavefunction files. If this behavior is undesirable, the quiet keyword argument may be set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.get_fermi","page":"File formats","title":"Electrum.get_fermi","text":"get_fermi(file) -> NamedTuple{(:fermi, :alphabeta), NTuple{2,Float64}}\n\nReads a VASP OUTCAR file and returns the Fermi energy and alpha+beta value.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing-3","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writeCONTCAR\nElectrum.writePOSCAR","category":"page"},{"location":"api/filetypes.html#Electrum.writeCONTCAR","page":"File formats","title":"Electrum.writeCONTCAR","text":"writePOSCAR([file = \"POSCAR\"], data; names = true, dummy = false, comment)\nwriteCONTCAR([file = \"CONTCAR\"], data; names = true, dummy = false, comment)\n\nWrites crystal data to a VASP POSCAR or CONTCAR output. The data can be a PeriodicAtomList or an AbstractCrystal. If a directory name is given instead of a file name, the data will be written to a file named POSCAR or CONTCAR in the provided directory, depending on the function used. If no argument is provided, it is written to POSCAR or CONTCAR in the current directory.\n\nBy default, atom names are written, but this is known to break VASP 4.6. This may be overridden by setting names to false, but this is known to cause its own incompatibility issues: it is known that VESTA, for instance, will crash if the line containing the atomic names is missing.\n\nDummy atoms are not are not written by default, but they may be written by setting dummy=true.\n\nThe first line, normally used to describe the system, may be altered by passing a printable object to comment.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.writePOSCAR","page":"File formats","title":"Electrum.writePOSCAR","text":"writePOSCAR([file = \"POSCAR\"], data; names = true, dummy = false, comment)\nwriteCONTCAR([file = \"CONTCAR\"], data; names = true, dummy = false, comment)\n\nWrites crystal data to a VASP POSCAR or CONTCAR output. The data can be a PeriodicAtomList or an AbstractCrystal. If a directory name is given instead of a file name, the data will be written to a file named POSCAR or CONTCAR in the provided directory, depending on the function used. If no argument is provided, it is written to POSCAR or CONTCAR in the current directory.\n\nBy default, atom names are written, but this is known to break VASP 4.6. This may be overridden by setting names to false, but this is known to cause its own incompatibility issues: it is known that VESTA, for instance, will crash if the line containing the atomic names is missing.\n\nDummy atoms are not are not written by default, but they may be written by setting dummy=true.\n\nThe first line, normally used to describe the system, may be altered by passing a printable object to comment.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"api/filetypes.html#Reading-5","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.read_lammps_data","category":"page"},{"location":"api/filetypes.html#Electrum.read_lammps_data","page":"File formats","title":"Electrum.read_lammps_data","text":"read_lammps_data(io::IO; atoms::AbstractVector = NamedAtom[]) -> PeriodicAtomList{3}\n\nReads a LAMMPS data file containing atomic coordinates. Currently, this function only supports 3D crystal data.\n\nIf set, the atom_types keyword can be used to define the types of atoms being read in. This can be and AbstractVector{NamedAtom}, AbstractVector{<:AbstractString}, or AbstractVector{<:Integer}. If it is not set or empty, then all atoms will be read in as dummy atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing-4","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.write_lammps_data","category":"page"},{"location":"api/filetypes.html#Electrum.write_lammps_data","page":"File formats","title":"Electrum.write_lammps_data","text":"write_lammps_data(io::IO, list::PeriodicAtomList, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for running a molecular dynamics simulation. \n\nIf transform is supplied, the list of atoms will be converted to a supercell with the associated transformation (either a matrix, vector, or scalar). The dummy keyword determines whether dummy atoms are included in the output (false by default).\n\nThis function currently only works for 3D systems, and outputs data for the LAMMPS metal unit system - most importantly, lengths are in angstrom.\n\n\n\n\n\nwrite_lammps_data(io::IO, xtal::AbstractCrystal, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for for running a molecular dynamics simulation. \n\nThe list of atoms that is written is given by converting xtal to a PeriodicAtomList, which uses the supplied transformation matrix to generate all atomic positions. If transform is supplied, the transformation will be applied to the PeriodicAtomList - it does not replace the transform provided with xtal.\n\nThis function currently only works for 3D systems.\n\n\n\n\n\nwrite_lammps_data(file, data, [transform]; dummy::Bool = false)\n\nWrites a LAMMPS data file to the path given by filename.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Crystal-data","page":"Crystal data","title":"Crystal data","text":"","category":"section"},{"location":"api/data.html#General","page":"Crystal data","title":"General","text":"","category":"section"},{"location":"api/data.html#Basic-data-grids","page":"Crystal data","title":"Basic data grids","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.DataGrid\nElectrum.RealDataGrid\nElectrum.ReciprocalDataGrid\nElectrum.fft\nElectrum.ifft\nAbstractFFTs.fftfreq(::DataGrid)\nElectrum.volume(::DataGrid)\nElectrum.voxelsize\nElectrum.integrate\nElectrum.partial_derivative\nElectrum.cell_gradient\nElectrum.gradient\nElectrum.directional_derivative\nElectrum.remove_shift ","category":"page"},{"location":"api/data.html#Electrum.DataGrid","page":"Crystal data","title":"Electrum.DataGrid","text":"Electrum.DataGrid{D,B<:LatticeBasis,S<:AbstractVector{<:Real},T} <: AbstractArray{T,D}\n\nStores a grid of values of type T defined in a D-dimensional crystal lattice basis of type B with a shift parameter of type S.\n\nBy convention, indexing of DataGrid is zero-based. This convention is used so that the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid. This is done with Electrum.reinterpret_index().\n\nLinear indexing is one-based like that of the underlying array.\n\nType aliases\n\nFor convenience, the aliases RealDataGrid and ReciprocalDataGrid are provided and are defined below:\n\nconst RealDataGrid{D} = DataGrid{RealBasis{D,Float64},SVector{D,Float64},D}\nconst ReciprocalDataGrid{D} = DataGrid{ReciprocalBasis{D,Float64},KPoint{D},D}\n\nNote that ReciprocalDataGrid uses a KPoint{D} to represent the shift, as opposed to an  SVector{D}. This allows for the concurrent storage of a weight along with the shift, which may be relevant for wavefunctions which exploit the symmetry of the k-point mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.RealDataGrid","page":"Crystal data","title":"Electrum.RealDataGrid","text":"Electrum.DataGrid{D,B<:LatticeBasis,S<:AbstractVector{<:Real},T} <: AbstractArray{T,D}\n\nStores a grid of values of type T defined in a D-dimensional crystal lattice basis of type B with a shift parameter of type S.\n\nBy convention, indexing of DataGrid is zero-based. This convention is used so that the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid. This is done with Electrum.reinterpret_index().\n\nLinear indexing is one-based like that of the underlying array.\n\nType aliases\n\nFor convenience, the aliases RealDataGrid and ReciprocalDataGrid are provided and are defined below:\n\nconst RealDataGrid{D} = DataGrid{RealBasis{D,Float64},SVector{D,Float64},D}\nconst ReciprocalDataGrid{D} = DataGrid{ReciprocalBasis{D,Float64},KPoint{D},D}\n\nNote that ReciprocalDataGrid uses a KPoint{D} to represent the shift, as opposed to an  SVector{D}. This allows for the concurrent storage of a weight along with the shift, which may be relevant for wavefunctions which exploit the symmetry of the k-point mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.ReciprocalDataGrid","page":"Crystal data","title":"Electrum.ReciprocalDataGrid","text":"Electrum.DataGrid{D,B<:LatticeBasis,S<:AbstractVector{<:Real},T} <: AbstractArray{T,D}\n\nStores a grid of values of type T defined in a D-dimensional crystal lattice basis of type B with a shift parameter of type S.\n\nBy convention, indexing of DataGrid is zero-based. This convention is used so that the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid. This is done with Electrum.reinterpret_index().\n\nLinear indexing is one-based like that of the underlying array.\n\nType aliases\n\nFor convenience, the aliases RealDataGrid and ReciprocalDataGrid are provided and are defined below:\n\nconst RealDataGrid{D} = DataGrid{RealBasis{D,Float64},SVector{D,Float64},D}\nconst ReciprocalDataGrid{D} = DataGrid{ReciprocalBasis{D,Float64},KPoint{D},D}\n\nNote that ReciprocalDataGrid uses a KPoint{D} to represent the shift, as opposed to an  SVector{D}. This allows for the concurrent storage of a weight along with the shift, which may be relevant for wavefunctions which exploit the symmetry of the k-point mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#AbstractFFTs.fft","page":"Crystal data","title":"AbstractFFTs.fft","text":"fft(g::RealDataGrid) -> ReciprocalDataGrid\nfft(g::ReciprocalDataGrid) -> RealDataGrid\n\nPerforms a fast Fourier transform on the data in a DataGrid.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.ifft","page":"Crystal data","title":"AbstractFFTs.ifft","text":"ifft(g::RealDataGrid) -> ReciprocalDataGrid\nifft(g::ReciprocalDataGrid) -> RealDataGrid\n\nPerforms an inverse fast Fourier transform on the data in a DataGrid.\n\nThe inverse FFT is normalized so that ifft(fft(g)) ≈ g (to within floating point error).\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.fftfreq-Tuple{DataGrid}","page":"Crystal data","title":"AbstractFFTs.fftfreq","text":"fftfreq(g::DataGrid{D}) -> Array{SVector{D,Float64},D}\n\nReturns the Fourier transform frequency bins for an DataGrid.\n\nFor real space data, the frequency bins will be angular wavenumbers, matching the 2π factors that are introduced when transforming between a RealBasis and a ReciprocalBasis. The convention used by FFTW.fftfreq() is also used: frequency bins at or above the Nyquist frequency will be negative.\n\nFor reciprocal space data, the frequencies are binned with the assumption that the lattice vectors are given in angular wavenumbers, and they represent real space coordinates. The Nyquist frequency convention is not used, so all elements will have positive indices.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.volume-Tuple{DataGrid}","page":"Crystal data","title":"Electrum.volume","text":"volume(g::DataGrid) -> eltype(basis(g))\n\nGets the crystal volume associated with a DataGrid. Units are assumed to be bohr³ for DataGrid types with a RealBasis, and rad³*bohr⁻³ for types with a ReciprocalBasis.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.voxelsize","page":"Crystal data","title":"Electrum.voxelsize","text":"voxelsize(g::DataGrid) -> eltype(basis(g))\n\nGets the size of a single real space voxel associated with a data grid. Units are assumed to be bohr³.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.integrate","page":"Crystal data","title":"Electrum.integrate","text":"integrate([f::Function = identity], g::RealDataGrid{D,T}) -> T\n\nApplies the function f elementwise to a datagrid, then integrates the grid across all voxels, accounting for the voxel volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.partial_derivative","page":"Crystal data","title":"Electrum.partial_derivative","text":"partial_derivative(g::RealDataGrid, dim::Integer)\n\nCalculates the partial derivative of g along coordinates with respect to the basis vector of dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.cell_gradient","page":"Crystal data","title":"Electrum.cell_gradient","text":"cell_gradient(g::RealDataGrid{D}) -> RealDataGrid{D,<:SVector{D}}\n\nCalculates the gradient of a RealDataGrid, which consists of vectors containing the components of the partial derivatives along coordinates with respect to the basis vectors of the unit cell. The gradient may need to be transformed to obtain a more standard result: for this, use the gradient() function.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.gradient","page":"Crystal data","title":"Electrum.gradient","text":"gradient(g::RealDataGrid{D}) -> RealDataGrid{D,<:SVector{D}}\n\nCalculates the gradient of a RealDataGrid, which consists of vectors containing the components of the partial derivatives along the orthonormal real space basis. The units of the output are those of the input multiplied by inverse bohr.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.directional_derivative","page":"Crystal data","title":"Electrum.directional_derivative","text":"directional_derivative(g::RealDataGrid{D}, v::AbstractVector) -> RealDataGrid{D}\n\nCalculates the directional derivative of a RealDataGrid along a vector v in Cartesian coordinates. Note that v does not need to be normalized, nor is it automatically normalized;  an unnormalized input will scale the results accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.remove_shift","page":"Crystal data","title":"Electrum.remove_shift","text":"remove_shift(g::RealDataGrid) -> RealDataGrid\n\nShifts the data in a RealDataGrid so that the shift vector of the new RealDataGrid is zero. Currently, only shifts for trivial cases (where the data shifting can be accomplished by a simple  circular shift of the array) are implemented; future implementations will need to use Fourier transforms to accomplish this task.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#FFT-iterators","page":"Crystal data","title":"FFT iterators","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.FFTLength\nElectrum.FFTBins","category":"page"},{"location":"api/data.html#Electrum.FFTLength","page":"Crystal data","title":"Electrum.FFTLength","text":"FFTLength <: AbstractVector{Int}\n\nThe one-dimensional counterpart to FFTBins, supporting only a single dimension. Its elements are plain Int types rather than the CartesianIndex of FFTBins.\n\nIn essence, it serves as a counterpart to Base.OneTo for FFT bins.\n\nExamples\n\njulia> Electrum.FFTLength(4)\n4-element FFTLength:\n 0\n 1\n -2\n -1\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.FFTBins","page":"Crystal data","title":"Electrum.FFTBins","text":"FFTBins{D} <: AbstractArray{CartesianIndex{D},D}\n\nAn iterable object defining a range of integer FFT bins. This can be used to convert a Cartesian array index to an FFT bin index, or vice versa.\n\nThe outputs use the convention where frequencies at or above the Nyquist frequency for that dimension are negative, matching the output of FFTW.fftfreq.\n\nExamples\n\njulia> FFTBins(4)\n4-element FFTIndices{1}:\n CartesianIndex(0,)\n CartesianIndex(1,)\n CartesianIndex(-2,)\n CartesianIndex(-1,)\n\njulia> FFTBins(3, 3)\n3×3 FFTIndices{2}:\n CartesianIndex(0, 0)   CartesianIndex(0, 1)   CartesianIndex(0, -1)\n CartesianIndex(1, 0)   CartesianIndex(1, 1)   CartesianIndex(1, -1)\n CartesianIndex(-1, 0)  CartesianIndex(-1, 1)  CartesianIndex(-1, -1)\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#k-points","page":"Crystal data","title":"k-points","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.KPoint\nElectrum.KPointMesh\nElectrum.nkpt\nElectrum.weight","category":"page"},{"location":"api/data.html#Electrum.KPoint","page":"Crystal data","title":"Electrum.KPoint","text":"KPoint{D} <: DenseVector{Float64}\n\nStores a k-point with an associated weight that corresponds to the number of symmetry-equivalent k-points, stored as an integer.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.KPointMesh","page":"Crystal data","title":"Electrum.KPointMesh","text":"KPointMesh{D} <: AbstractVector{KPoint{D}}\n\nContains a list of k-points associated with a matrix describing the mesh that was used to generate the points, and its shift off the Γ point (origin). If the mesh used to generate the points is unknown, it will be set to the zero matrix of dimension D.\n\nA KPointMesh can be indexed as if it were an ordinary Vector{KPoint{D}}.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.nkpt","page":"Crystal data","title":"Electrum.nkpt","text":"nkpt(k::KPointMesh) -> Int\n\nCounts the number of k-points (equivalent to length(k)). This function can be defined for custom types that contain a KPointMesh.\n\n\n\n\n\nnkpt(x) -> Int\n\nCounts the number of explicitly enumerated k-points associated with an object containing a KPointMesh.\n\nBy default, this function returns length(KPointMesh(x)), so defining KPointMesh(x::T) for a type T containing a KPointMesh will automatically define nkpt(x::T).\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.weight","page":"Crystal data","title":"Electrum.weight","text":"weight(k::KPoint) -> Int\n\nReturns the weight associated with a k-point.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Spin-states","page":"Crystal data","title":"Spin states","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.Multiplicity\nElectrum.SpinBivector","category":"page"},{"location":"api/data.html#Electrum.Multiplicity","page":"Crystal data","title":"Electrum.Multiplicity","text":"Multiplicity{M} <: AbstractUnitRange{Rational{Int}}\n\nRepresents a valid range of spin states corresponding with multiplicity M. These index as if they  are UnitRange{Rational{Int}} objects of the form -(M - 1)//2:(M - 1)//2, and can be converted to UnitRange objects with the UnitRange constructor.\n\nThese types are singleton types with a numeric Int parameter, allowing for its use as a type parameter in other types which require information on the spin multiplicity or allowed spin states.\n\nExamples\n\njulia> UnitRange(SpinRange{3}())\n1:1\n\njulia> SpinRange{4}() == -3//2:3//2\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.SpinBivector","page":"Crystal data","title":"Electrum.SpinBivector","text":"SpinBivector{D,T}\n\nA skew-symmetric matrix representing a spin bivector in  D dimensions. No automatic normalization has been implemented for this type.\n\nWhy the spin axis is a bivector\n\nThe identification of a spin direction with a vector is only possible in 3D. This is because the axis of rotation is defined by the Hodge dual of the rotation plane. The Hodge dual is a linear map relating k-dimensional objects in  D-dimensional space to D-k-dimensional objects in the same space. \n\nA bivector is a 2-dimensional object, and in three dimensions, its Hodge dual is a vector. This is not the case in any other number of dimensions. To allow for generality in describing spin, this representation is used instead.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Energies-and-occupancies","page":"Crystal data","title":"Energies and occupancies","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.EnergyOccupancy\nElectrum.EnergiesOccupancies\nElectrum.energy\nElectrum.occupancy\nElectrum.energies\nElectrum.occupancies\nElectrum.min_energy\nElectrum.max_energy\nElectrum.min_occupancy\nElectrum.max_occupancy\nElectrum.fermi","category":"page"},{"location":"api/data.html#Electrum.EnergyOccupancy","page":"Crystal data","title":"Electrum.EnergyOccupancy","text":"EnergyOccupancy{T<:Real}\n\nA data structure consisting of a pair of an energy value and an occupancy number, both of type T. Energies are assumed to be in Hartree. Occupancy values are not constrained, but will generally range from 0 to 2 for the results of restricted calculations (no separate treatment of spins), or from 0 to 1 for unrestricted calculations (wavefunctions with separate spins).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.EnergiesOccupancies","page":"Crystal data","title":"Electrum.EnergiesOccupancies","text":"EnergiesOccupancies{T,N} <: AbstractArray{EnergyOccupancy{T},N}\n\nType alias for Array{EnergyOccupancy{T},N}. Data structures S which contain EnergyOccupancy values in a collection should define the constructor EnergiesOccupancies(::S).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.energy","page":"Crystal data","title":"Electrum.energy","text":"energy(eo::EnergyOccupancy{T}) -> T\n\nReturns the energy value in an EnergyOccupancy.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.occupancy","page":"Crystal data","title":"Electrum.occupancy","text":"occupancy(eo::EnergyOccupancy{T}) -> T\n\nReturns the occupancy value in an EnergyOccupancy.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.energies","page":"Crystal data","title":"Electrum.energies","text":"energies(x) -> Array{<:Real}\n\nReturns the energy data associated with a collection of EnergyOccupancy{T} objects. By default, this falls back to energy.(EnergyOccupancy(x)).\n\n\n\n\n\nenergies(d::AbstractDensityOfStates; usefermi=false) -> Vector{Float64}\n\nGets the range of energies in the dataset. If usefermi is set to true, the energies returned will be adjusted such that the Fermi energy is set to zero.\n\nThere are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.occupancies","page":"Crystal data","title":"Electrum.occupancies","text":"occupancies(x) -> Array{<:Real}\n\nReturns the occupancy data associated with a collection of EnergyOccupancy{T} objects. By default, this falls back to occupancy.(EnergyOccupancy(x)).\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.min_energy","page":"Crystal data","title":"Electrum.min_energy","text":"min_energy(x) -> Real\n\nReturns the minimum energy in a collection of EnergyOccupancy data or an object containing such data.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.max_energy","page":"Crystal data","title":"Electrum.max_energy","text":"max_energy(x) -> Real\n\nReturns the maximum energy in a collection of EnergyOccupancy data or an object containing such  data.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.min_occupancy","page":"Crystal data","title":"Electrum.min_occupancy","text":"min_occupancy(x) -> Real\n\nReturns the minimum occupancy in a collection of EnergyOccupancy data or an object containing such data. For most raw calculation data, this should return zero if unoccupied states were considered.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.max_occupancy","page":"Crystal data","title":"Electrum.max_occupancy","text":"max_occupancy(x) -> Real\n\nReturns the maximum occupancy in a collection of EnergyOccupancy data or an object containing such data. For a restricted calculation (no explicit treatment of spin), this is usually around 2, and for an unrestricted calculation (explicit spin treatment) this is usually around 1.\n\nIn many cases, you may want to determine the maximum possible occupancy value, not the maximum in the dataset, in which case, you should use round(Int, max_occupancy(a), RoundUp).\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.fermi","page":"Crystal data","title":"Electrum.fermi","text":"fermi(x) -> Real\n\nEstimates the Fermi energy using the provided energy and occupancy data by interpolating the data between the occupancies nearest half of the maximum occupancy.\n\n\n\n\n\nfermi(d::AbstractDensityOfStates) -> Float64\n\nGets the Fermi energy from DOS data. There are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Wavefunctions","page":"Crystal data","title":"Wavefunctions","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.PlanewaveWavefunction\nElectrum.PlanewaveIndex\nElectrum.nspin\nElectrum.nband(::PlanewaveWavefunction)\nElectrum.nonzero_g_indices\nElectrum.nonzero_g_vectors","category":"page"},{"location":"api/data.html#Electrum.PlanewaveWavefunction","page":"Crystal data","title":"Electrum.PlanewaveWavefunction","text":"PlanewaveWavefunction{D,T} <: AbstractArray{T,D}\n\nStores the components of a wavefunction constructed from a planewave basis. Usually, the coefficient data type T will be a ComplexF32, as in DFT calculations, double precision convergence of the density will correspond to single-precision converegnce of the wavefunction.\n\nInternally, coefficients are stored in an Array{4,T}. Indexing is then manually implemented, with a D-dimensional CartesianIndex used for accessing each coefficient associated with a G-vector. PlanewaveWavefunction instances are mutable, with getindex() and setindex!() defined for them, but they are not resizable, and the backing array should not be resized.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.PlanewaveIndex","page":"Crystal data","title":"Electrum.PlanewaveIndex","text":"Electrum.PlanewaveIndex{D}\n\nA special indexing type used to index the components of wavefunctions in a planewave basis.\n\nIn many computational chemistry packages, the standard indexing of wavefunction components occurs in the following canonical order: spins, k-points, bands, then the h, k, and l indices of the G-vectors associated with the coefficients. However, in many cases, users will want to select a spin, k-point, or band before selecting a G-vector index.\n\nTo keep the syntax intuitive while maintaining performance (mostly by ensuring that all of the components of a wavefunction are stored compactly) this index type ensures that the iteration occurs in a natural order for users and in an efficient order for Julia.\n\nThis also ensures that G-vectors with negative indices are handled correctly: while the canonical G-vectors are those within some defined ranges of indices, out of bounds indices are reinterpreted automatically using modulo arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.nspin","page":"Crystal data","title":"Electrum.nspin","text":"nspin(wf::PlanewaveWavefunction) -> Int\n\nReturns the number of spins associated with a PlanewaveWavefunction.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.nband-Tuple{PlanewaveWavefunction}","page":"Crystal data","title":"Electrum.nband","text":"nband(wf::PlanewaveWavefunction) -> Int\n\nReturns the number of bands (occupied and unoccupied) associated with a PlanewaveWavefunction.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.nonzero_g_indices","page":"Crystal data","title":"Electrum.nonzero_g_indices","text":"nonzero_g_indices(wf::PlanewaveWavefunction{D}) -> Vector{CartesianIndex{D}}\n\nReturns a vector of CartesianIndex objects corresponding to planewave G-vector indices that are not all zero at each band and k-point.\n\nTo return the G-vectors as objects which subtype AbstractVector, nonzero_g_vectors(wf) may be  used instead, which is equivalent to calling SVector.(Tuple.(nonzero_g_indices(wf))).\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.nonzero_g_vectors","page":"Crystal data","title":"Electrum.nonzero_g_vectors","text":"nonzero_g_vectors(wf::PlanewaveWavefunction{D}) -> Vector{SVector{D,Int}}\n\nReturns a vector of SVector{D,Int} objects corresponding to planewave G-vectors that are not all zero at each band and k-point.\n\nThis is equivalent to calling SVector.(Tuple.(nonzero_g_indices(wf))), and can be used whenever AbstractVector inputs are needed instead of a CartesianIndex.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Band-structures","page":"Crystal data","title":"Band structures","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.BandAtKPoint\nElectrum.BandStructure\nElectrum.nband(::BandStructure)\nElectrum.nband(::BandAtKPoint)\nElectrum.FatBands","category":"page"},{"location":"api/data.html#Electrum.BandAtKPoint","page":"Crystal data","title":"Electrum.BandAtKPoint","text":"BandAtKPoint\n\nStores information about a band's energy and its occupancy at a specific k-point.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.BandStructure","page":"Crystal data","title":"Electrum.BandStructure","text":"BandStructure{D}\n\nStores information about an electronic band structure, including the list of k-points used to generate the data (as an AbstractVector{KPoint{D}}) and the band information at every k-point (as a Vector{BandAtKPoint}).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.nband-Tuple{BandStructure}","page":"Crystal data","title":"Electrum.nband","text":"nband(b::BandStructure) -> Int\n\nReturns the number of bands (occupied and unoccupied) associated with a BandStructure.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.nband-Tuple{BandAtKPoint}","page":"Crystal data","title":"Electrum.nband","text":"nband(b::BandAtKPoint) -> Int\n\nReturns the number of bands associated with a k-point.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.FatBands","page":"Crystal data","title":"Electrum.FatBands","text":"FatBands{D}\n\nStores information relevant to plotting fatbands.\n\nFatBands.bands: matrix of energies at each [kpt, band].\nFatBands.projband: array of lm-decomposed band structure. [orbital, ion, band, kpt].\nFatBands.cband: array of complex-valued contributions to band structure.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Density-of-states","page":"Crystal data","title":"Density of states","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.AbstractDensityOfStates\nElectrum.DensityOfStates\nElectrum.ProjectedDensityOfStates\nElectrum.fermi(::AbstractDensityOfStates)\nElectrum.smear\nElectrum.energies(::AbstractDensityOfStates)\nElectrum.nelectrons","category":"page"},{"location":"api/data.html#Electrum.AbstractDensityOfStates","page":"Crystal data","title":"Electrum.AbstractDensityOfStates","text":"AbstractDensityOfStates\n\nSupertype for all density of states data.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.DensityOfStates","page":"Crystal data","title":"Electrum.DensityOfStates","text":"DensityOfStates\n\nContains the total density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.ProjectedDensityOfStates","page":"Crystal data","title":"Electrum.ProjectedDensityOfStates","text":"ProjectedDensityOfStates\n\nContains projected density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.fermi-Tuple{AbstractDensityOfStates}","page":"Crystal data","title":"Electrum.fermi","text":"fermi(d::AbstractDensityOfStates) -> Float64\n\nGets the Fermi energy from DOS data. There are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.smear","page":"Crystal data","title":"Electrum.smear","text":"smear(dos::DensityOfStates, sigma::Real)\n\nSmears the DOS function by convoluting it with a normalized Gaussian function with width sigma.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.energies-Tuple{AbstractDensityOfStates}","page":"Crystal data","title":"Electrum.energies","text":"energies(d::AbstractDensityOfStates; usefermi=false) -> Vector{Float64}\n\nGets the range of energies in the dataset. If usefermi is set to true, the energies returned will be adjusted such that the Fermi energy is set to zero.\n\nThere are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.nelectrons","page":"Crystal data","title":"Electrum.nelectrons","text":"nelectrons(d::DensityOfStates)\n\nGets the approximate number of electrons that are needed to reach the Fermi level.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Atomic-data","page":"Crystal data","title":"Atomic data","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.SphericalHarmonic\nLinearAlgebra.dot(::SphericalHarmonic, ::SphericalHarmonic)","category":"page"},{"location":"api/data.html#Electrum.SphericalHarmonic","page":"Crystal data","title":"Electrum.SphericalHarmonic","text":"SphericalHarmonic{Lmax}\n\nReal spherical harmonic components up to Lmax. This can be used to describe atomic orbitals or projections of data onto atomic sites.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#LinearAlgebra.dot-Tuple{SphericalHarmonic, SphericalHarmonic}","page":"Crystal data","title":"LinearAlgebra.dot","text":"dot(sh1::SphericalHarmonics, sh2::SphericalHarmonics) -> Float64\n\nCalculates the dot product between the components of two spherical harmonics, which can be used to measure the degree of similarity between them. Note that this does not account for differences in rotation between the spherical harmonics.\n\n\n\n\n\n","category":"method"},{"location":"lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The starting point for solid state structures is a periodic lattice. Electrum provides convenient types and functions for working with lattices of arbitrary dimension, not just three dimensions. ","category":"page"},{"location":"lattices.html#Real-and-reciprocal-space-traits","page":"Lattices","title":"Real and reciprocal space traits","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The Electrum.BySpace{D} supertype contains two types, Electrum.ByRealSpace{D} and Electrum.ByReciprocalSpace{D}, where D is the number of dimensions associated with the dataset. These types are used to denote whether data is associated with real space (e.g. electron density) or  reciprocal space (e.g. the Fourier transform of the electron density). When working with lattices, it is important to distinguish the two types of lattice: this is the primary reason why bare SMatrix{D,D,T} instances are not used in this package.","category":"page"},{"location":"lattices.html#Electrum.LatticeBasis-and-methods","page":"Lattices","title":"Electrum.LatticeBasis and methods","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The Electrum.LatticeBasis{S<:Electrum.BySpace,D,T} data type is a wrapper for an SMatrix{D,D,T,D^2} which represents the real or reciprocal space basis vectors of a lattice.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Electrum does not export Electrum.LatticeBasis, but instead provide the following aliases. This allows developers to alter the implementation of Electrum.LatticeBasis without breaking the API:","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"const RealBasis = Electrum.LatticeBasis{ByRealSpace}\nconst ReciprocalBasis = Electrum.LatticeBasis{ByReciprocalSpace}\nconst AbstractBasis = Electrum.LatticeBasis{<:BySpace}","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"warning: Warning\nNote that RealBasis{D} === Electrum.LatticeBasis{ByRealSpace,D}, and not Electrum.LatticeBasis{ByRealSpace{D},D}. While the latter is a valid type and can be used to store data, the result of Electrum.DataSpace(::Electrum.LatticeBasis{ByRealSpace{D},D}) is an error!","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The units of RealBasis are bohr, and those of ReciprocalBasis are radians over bohr, corresponding with the convention that the dot product of a real basis vector with a corresponding reciprocal basis vector is 2π.","category":"page"},{"location":"lattices.html#Construction","page":"Lattices","title":"Construction","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"A RealBasis or ReciprocalBasis can be constructed from an AbstractMatrix, Tuple, or iterator of the correct size.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"In the case of a StaticMatrix, the size and element type are already known, so the constructors can simply be called as RealBasis or ReciprocalBasis:","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"julia> RealBasis(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))\nElectrum.LatticeBasis{Electrum.ByRealSpace, 3, Int64}:\n    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)\n    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)\n    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"However, in the case of a Matrix or other dynamically sized data, the dimension is not known and should be supplied to avoid an exception being thrown. This is to avoid type instability arising from determining the size at runtime:","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"julia> RealBasis{3}([1 0 0; 0 2 0; 0 0 3])\nElectrum.LatticeBasis{Electrum.ByRealSpace, 3, Int64}:\n    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)\n    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)\n    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"In either case, you can supply the element type (though it must be proceeded by the dimension in all cases) to convert the input elements to the desired type (here, it's Float32):","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"julia> RealBasis{3,Float32}(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))\nElectrum.LatticeBasis{Electrum.ByRealSpace, 3, Float32}:\n    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)\n    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)\n    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)","category":"page"},{"location":"lattices.html#Conversion","page":"Lattices","title":"Conversion","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"A RealBasis can be converted to a ReciprocalBasis via Base.convert or their constructors, and vice versa:","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"b = ReciprocalBasis(a)\nc = convert(RealBasis, b)","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"tip: Tip\nAvoid needless back-and-forth conversions between RealBasis and ReciprocalBasis to avoid numerical instabilities.","category":"page"},{"location":"lattices.html#Mathematical-operations","page":"Lattices","title":"Mathematical operations","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The RealBasis and ReciprocalBasis types support the majority of common operations used in  solid-state chemistry, including addition, subtraction, multiplication, left division, and right division. ","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Importantly, it supports the QR decomposition provided by LinearAlgebra.qr. This decomposition is useful in that it generates a Q factor, which is an orthogonal matrix (representing a Euclidean point isometry - compositions of rotations and reflections) and an R factor, which is an upper triangular matrix. This operation is useful in converting lattices to a standard orientation: in the case of a QR decomposition, the R factor places the first basis vector of the lattice along the first basis vector of space. In 3D, this means that veca is collinear with vecx.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Calling LinearAlgebra.qr(::AbstractBasis{D,T}) returns a StaticArrays.QR{SMatrix{D,D,T,D^2}, SMatrix{D,D,T,D^2}, SVector{D,Int}}, so the Q and R factors are bare SMatrix instances. While this is fine for the Q matrix, the R matrix represents a basis, and we expect an AbstractBasis return value. The triangularize function returns the R factor of a QR decomposition as an AbstractBasis, discarding the Q factor.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.triangularize","category":"page"},{"location":"lattices.html#Electrum.triangularize-lattices","page":"Lattices","title":"Electrum.triangularize","text":"triangularize(l::T) where T<:LatticeBasis -> T\n\nConverts a set of basis vectors to an upper triangular form using QR decomposition.\n\n\n\n\n\ntriangularize(l::T, sc::AbstractMatrix{<:Integer}) where T<:LatticeBasis -> T\n\nConverts a set of basis vectors to an upper triangular form using QR decomposition, with an included conversion to a larger supercell. The resulting matrix that describes the basis vectors will have only positive values along the diagonal, and therefore, is always right-handed (regardless of the transformation matrix used).\n\nLAMMPS expects that basis vectors are given in this format.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"note: Note\nSupport for the corresponding LQ decomposition (where L is a lower triangular matrix) is not yet implemented.","category":"page"},{"location":"lattices.html#Implementation-details","page":"Lattices","title":"Implementation details","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The SMatrix{D1,D2,T,L} type requires four type parameters - D1 and D2 are each of the matrix dimensions, and T is the element type of the matrix. However, one last parameter is needed: L,  the length of the NTuple that backs the SMatrix.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a problem in the declaration of structs. Technically, a type like SMatrix{3,3,Float64} is an abstract type, as the L parameter is undeclared, even though the value of L is always D1 * D2. By declaring a struct to have this type, there seems to be a performance drop.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The LatticeBasis types wrap an SVector{D,SVector{D,Float64}}. This only requires a single  type parameter D, and allows for fully concrete struct declarations. The :matrix property converts this data to an SMatrix{D,D,T,D^2} instance, and methods needing to access something that looks like a matrix reference this property.","category":"page"},{"location":"lattices.html#Basis-vectors-in-composite-types","page":"Lattices","title":"Basis vectors in composite types","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Some types (such as Electrum.DataGrid) store a set of basis vectors as part of the dataset. The basis function allows a user to access that set of basis vectors. By default, basis(x) returns x.basis, so defining a field basis::RealBasis{...} or basis::ReciprocalBasis{...} implements these functions automatically.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"warning: Warning\nbasis(x) returns an AbstractBasis, but there is no guarantee whether the return type is RealBasis or ReciprocalBasis. Use convert(::Type{<:AbstractBasis}, basis(x)) to ensure that the return type is what you expect.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"The type of basis vectors stored also allows for inference of the data space trait, as the default definition of DataSpace(::Type{T}) is fieldtype(T, :basis). We encourage you to choose your basis vector type to match the data you wish to represent.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"note: Note\nFor performance reasons, we encourage you to define struct fields with concrete types, and use  type parameters in your struct definitions to ensure that the type is concrete.","category":"page"},{"location":"filetypes.html#File-formats","page":"File formats","title":"File formats","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl supports a variety of different file formats from abinit, VASP, and LAMMPS.","category":"page"},{"location":"filetypes.html#ABINIT","page":"File formats","title":"ABINIT","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Outputs from abinit 7.10.5 and abinit 8.10.3 are supported and have been tested. The headers from these versions contain the numbers 57 and 80 respectively. Fundamentally, these files are FORTRAN binary files written in sequential access mode with 4-byte record markers.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The file reading functionality from this package has not been tested on outputs from other versions of abinit, but may work for the outputs of other abinit versions. However, these functions will fail if the header does not contain either of those numbers in the header.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"If other header formats are known to work, please file an issue to extend support for abinit outputs to that format.","category":"page"},{"location":"filetypes.html#Densities-and-potentials","page":"File formats","title":"Densities and potentials","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Density outputs are suffixed with _DEN when written by abinit. Depending on the calculation type, there can be either 1, 2, or 4 components (depending on the value of nsppol). The first component is always the total density.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"There is also the kinetic energy density with suffix _KDEN which should use the same format as electron density files.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Potential outputs can have several different suffixes depending on the component of the potential chosen to be written:","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"_POT: Total potential.\n_VPSP: Local components of the pseudopotentials used.\n_VHA: Hartree potential.\n_VHXC: Sum of the Hartree and exchange-correlation potentials.\n_VXC: Exchange-correlation potential. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Both density and potential files follow the same format. The read_abinit_DEN() and  read_abinit_POT() functions can be used to load in density and potential files.","category":"page"},{"location":"filetypes.html#Wavefunctions","page":"File formats","title":"Wavefunctions","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Wavefunctions can be read in by read_abinit_WFK(). This assumes that the wavefunction is stored by k-points (istwfk should be equal to nkpt*1 in the input file).","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Because wavefunctions are large files, and reading them can be slow, read_abinit_WFK() will print @info messages for every k-point that is read in. This can be disabled by setting the keyword argument quiet = true.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"warning: Warning\nabinit 7.10.5 (header version 57) does not output the matrix associated with the k-point mesh used in the calculation (the kptrlatt field). The matrix contained in the associated KPointMesh{3} object will be zero.","category":"page"},{"location":"filetypes.html#VASP","page":"File formats","title":"VASP","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"File reading and writing has been tested with VASP 4. While the functions listed here are not guaranteed to work for future VASP versions, many can still be expected to work.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"By default, all functions that read VASP outputs will are named read<FILENAME>(). If called without arguments, or with a directory argument, they will search the current working directory or the directory argument for a file with the name FILENAME, as VASP calculations will generate those particular filenames in a directory where a calculation was run.","category":"page"},{"location":"filetypes.html#Files-generated-by-VASP-calculations","page":"File formats","title":"Files generated by VASP calculations","text":"","category":"section"},{"location":"filetypes.html#DOSCAR","page":"File formats","title":"DOSCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The DOSCAR file contains data need to plot a density of states curve.","category":"page"},{"location":"filetypes.html#POSCAR-and-CONTCAR","page":"File formats","title":"POSCAR and CONTCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The POSCAR file contains the basis vectors and all of the atomic positions used to generate a crystal structure.  The CONTCAR file is where the atomic positions from a calculation are written, and its format is identical to that of the POSCAR file. In the case of geometry optimizations, the contents of CONTCAR will differ from those of POSCAR. readPOSCAR() and readCONTCAR() will read these files into a PeriodicAtomList{3}.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"info: Info\nPOSCAR files supported by VASP 4 do not contain explicit atomic identity information. If those are read in without modification, dummy atoms with numeric labels will be used instead of the true atom names.","category":"page"},{"location":"filetypes.html#PROCAR","page":"File formats","title":"PROCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The PROCAR file contains data needed to plot fat bands (band structures that contain information about contributions from atomic orbitals).","category":"page"},{"location":"filetypes.html#WAVECAR","page":"File formats","title":"WAVECAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The WAVECAR file contains the coefficients for the wavefunction's reciprocal space representation at each k-point. The wavefunction is stored in an order with sparse, implied indexing. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"warning: Warning\nVASP does not store the weights of k-points in the WAVECAR, nor does it store the matrix that generated the k-point mesh. Naïve summing of quantities associated with each k-point should be avoided.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Like read_abinit_wavefunction(), readWAVECAR() will print @info messages by default for each k-point read in. This can be disabled by setting the keyword argument quiet = true.","category":"page"},{"location":"filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl supports the reading and writing of LAMMPS atomic position data.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"info: Info\nLike VASP POSCAR files, LAMMPS data files do not contain explicit atomic information. If none is provided, dummy atoms corresponding to each atom type will be used.","category":"page"},{"location":"filetypes.html#TOML","page":"File formats","title":"TOML","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl can export AbstractAtomPosition and Crystal data to TOML files through the writeTOML(file, data) function. The internal Electrum.toml_convert() can be used to convert data to a dictionary that TOML.print() can support.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"This functionality works only if the TOML module is loaded (as a weak dependency through Requires). If it is not available, run the following command in the REPL:","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"julia> using TOML","category":"page"},{"location":"grids.html#Data-grids","page":"Data grids","title":"Data grids","text":"","category":"section"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"The output of many quantum chemistry packages are datasets defined on a spatial grid in real or reciprocal space. Theoretical tools may want to perform mathematical operations on this data, but operating on bare arrays containing the dta requires tracking properties associated with each array, such as the basis vectors of the lattice","category":"page"},{"location":"grids.html#DataGrid,-RealDataGrid,-and-ReciprocalDataGrid","page":"Data grids","title":"DataGrid, RealDataGrid, and ReciprocalDataGrid","text":"","category":"section"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"An DataGrid{D,B<:Electrum.LatticeBasis,S<:AbstractVector{<:Real},T} contains data defined in a crystal lattice of D with basis vectors of type B, a shift parameter of type S, and elements of type T, either in real space (RealDataGrid) or in reciprocal space (ReciprocalDataGrid). These aliases are defined as follows:","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"const RealDataGrid{D,T} = DataGrid{D,RealBasis{D,Float64},SVector{D,Float64},T}\nconst ReciprocalDataGrid{D,T} = DataGrid{D,ReciprocalBasis{D,Float64},KPoint{D},T}","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"note: Note\nLook closely at the above definition: the shift data type for RealDataGrid{D} is SVector{D,Float64}, but the shift data type for ReciprocalDataGrid{D} is KPoint{D}. When the DataGrid constructor without the shift type parameter is invoked, the basis type is used to infer the appropriate shift type so that a RealDataGrid or ReciprocalDataGrid is constructed.","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"DataGrid uses zero-based, periodic indexing: the first index of an AbstractDataGrid{D} is zero(NTuple{D,Int}), and indices whose moduli with respect to size along that dimension are identical will reference the same element: for instance, for g::AbstractDataGrid{3} with size (10, 10, 10), g[69, 420, 1337] === g[9, 0, 7]. Encountering a BoundsError is not possible when indexing an DataGrid.","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"The basis of an DataGrid can be recovered with basis(::DataGrid), which will be of the type specified by the type parameter. ","category":"page"},{"location":"grids.html#Broadcasting-and-mathematical-operations","page":"Data grids","title":"Broadcasting and mathematical operations","text":"","category":"section"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"Broadcasting is defined for DataGrid with a custom Base.Broadcast.BroadcastStyle subtype:","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"Electrum.DataGridStyle{D,B,S} <: Broadcast.AbstractArrayStyle{D}","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"This allows DataGrid instances to operated on with dot syntax. However, they must share lattice basis vectors and shift values. If they do not match, an Electrum.LatticeMismatch exception will be thrown.","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"info: Info\nAlthough Base.Broadcast.ArrayStyle is usually overridden by other subtypes of  Base.Broadcast.AbstractArrayStyle, it does not override Electrum.DataGridStyle. Adding a DataGrid to an Array returns an Array, and adding a DataGrid to other AbstractArray subtypes returns the AbstractArray subtype defined by the Broadcast.BroadcastStyle. In the  case of a dimension mismatch, the broadcast style wll be Broadcast.ArrayConflict - the operation will throw a DimensionMismatch.","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"The + and - operators are defined for DataGrid instances, and they are faster than the broadcasted .+ and .- equivalents. As with the broadcasted versions, checks are implemented to ensure that the lattice basis vectors and shifts match.","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"Similarly, the *, /, and \\ operators are defined for pairs of DataGrid and Number instances, and again, are faster than their broadcasted equivalents.","category":"page"},{"location":"grids.html#Fourier-transforms","page":"Data grids","title":"Fourier transforms","text":"","category":"section"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"The Fourier transform and its inverse are available through an overload of FFTW.fft() and FFTW.ifft(). The transforms are normalized with respect to the basis vectors of the space, so for g::DataGrid, ifft(fft(g)) ≈ g (to within floating point error).","category":"page"},{"location":"grids.html","page":"Data grids","title":"Data grids","text":"fft and ifft defined for DataGrid generally, but it is critical to note that in the vast majority of cases, you will want to call fft on RealDataGrid instances and ifft on ReciprocalDataGrid instances.","category":"page"},{"location":"api/crystals.html#Crystals","page":"Crystals","title":"Crystals","text":"","category":"section"},{"location":"api/crystals.html#Constructors-and-types","page":"Crystals","title":"Constructors and types","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.AbstractCrystal\nElectrum.Crystal\nElectrum.CrystalWithDatasets","category":"page"},{"location":"api/crystals.html#Electrum.AbstractCrystal","page":"Crystals","title":"Electrum.AbstractCrystal","text":"AbstractCrystal{D}\n\nA crystal structure in D dimensions, containing information about the lattice, space group, and atoms contained within the crystal.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.Crystal","page":"Crystals","title":"Electrum.Crystal","text":"Crystal{D} <: AbstractCrystal{D}\n\nA crystal structure in D dimensions. Contains information about the lattice, space group, and atoms. This is a mutable data structure.\n\nAt minimum, a list of atomic positions (as an AtomList) is needed to generate a Crystal. Optionally, space group number and the origin of the space group may be provided.\n\nA transform may also be specified that converts the basis vectors of the AtomList to a favored representation, most often the conventional lattice. If it is not specified, it is filled with an identity matrix by default. The matrix is right-multiplied with the basis vectors to produce the favored representation. Because the rows of the transformation naturally correspond to the operations performed on each constituent basis vector, it may be easier to enter the transform as a transpose (or equivalently, an adjoint) when entered manually.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.CrystalWithDatasets","page":"Crystals","title":"Electrum.CrystalWithDatasets","text":"CrystalWithDatasets{D,K,V} <: AbstractCrystal{D}\n\nA pairing of a Crystal{D} and a Dict{K,V} which allows for access to associated datasets.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Methods","page":"Crystals","title":"Methods","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.generators\nElectrum.get_transform\nElectrum.set_transform!","category":"page"},{"location":"api/crystals.html#Electrum.generators","page":"Crystals","title":"Electrum.generators","text":"generators(xtal::AbstractCrystal{D}) -> PeriodicAtomList{D}\n\nReturns the list of generating atomic positions associated with a Crystal or CrystalWithDatasets.\n\nNote that this does not convert the input to a PeriodicAtomList with all atomic positions; only the minimal set that's needed to generate the atoms given the space group symmetry. To enumerate all of the atoms, use convert(PeriodicAtomList, xtal) or PeriodicAtomList(xtal).\n\n\n\n\n\n","category":"function"},{"location":"api/crystals.html#Electrum.get_transform","page":"Crystals","title":"Electrum.get_transform","text":"get_transform(xtal::AbstractCrystal{D}) -> SMatrix{D,D,Int}\n\nReturns the transformation matrix associated with an AbstractCrystal.\n\n\n\n\n\n","category":"function"},{"location":"api/crystals.html#Electrum.set_transform!","page":"Crystals","title":"Electrum.set_transform!","text":"set_transform!(xtal::AbstractCrystal, M) -> AbstractCrystal\n\nSets the transform supplied with an AbstractCrystal. The transform can be an integer matrix, vector, scalar, or UniformScaling, which is converted to an SMatrix{D,D,Int} when stored.\n\nThe function returns the modified input for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"api/lattices.html#Constructors-and-types","page":"Lattices","title":"Constructors and types","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.RealBasis\nElectrum.ReciprocalBasis\nElectrum.AbstractBasis","category":"page"},{"location":"api/lattices.html#Electrum.RealBasis","page":"Lattices","title":"Electrum.RealBasis","text":"Electrum.LatticeBasis{S<:Electrum.BySpace,D,T} <: StaticMatrix{D,D,T}\n\nRepresents the basis vectors of a D-dimensional lattice in real or reciprocal space, depending on S. The units of LatticeBasis{Electrum.ByRealSpace} are bohr, and those of LatticeBasis{Electrum.ByReciprocalSpace} are rad*bohr⁻¹, corresponding to the convention that the dot product of a real space basis vector with a reciprocal space basis vector is 2π.\n\nType aliases\n\nFor convenience, the type aliases RealBasis and ReciprocalBasis are defined below:\n\nconst RealBasis = LatticeBasis{ByRealSpace}\nconst ReciprocalBasis = LatticeBasis{ByReciprocalSpace}\nconst AbstractBasis = LatticeBasis{<:BySpace}\n\nThese type aliases are exported, and in most circumstances code should refer to these types for the sake of readability, not Electrum.LatticeBasis, which is unexported.\n\nMathematical operations\n\nElectrum.LatticeBasis behaves as an ordinary matrix and should support all mathematical operations commonly used, including left division with vectors (\\), commonly used in the conversion between Cartesian and fractional (reduced) coordinates.\n\nIn most cases, matrix multiplications will convert the result to an ordinary StaticArray or Array. However, right multiplications of an Electrum.LatticeBasis{S,D} with an  SMatrix{D,D,<:Integer} are treated as the application of a supercell building operation, and  return a new Electrum.LatticeBasis{S,D} instead.\n\nConversion\n\nA RealBasis may be converted to a ReciprocalBasis, or vice versa, using either convert(T::Electrum.LatticeBasis, b) or the constructor (T::Type{<:Electrum.LatticeBasis})(b). This automatically multiplies or divides by 2π as needed.\n\nThe inverse operation inv also performs this conversion. This convention may change in a future update, as the current definition may break other assumptions about matrix inversion.\n\nInteroperability\n\nFile import and export methods in Electrum and any other software which returns these types must perform unit conversion if the units used by the other software package are different.\n\nInternals\n\nIn order to avoid the presence of an extraneous type parameter, the backing vectors field of a LatticeBasis is not an SMatrix{D,D,T} (as this is not a concrete type), but an  SVector{D,SVector{D,T}}. However, the property matrix is defined so that it returns an SMatrix{D,D,T}. The vectors property is private, and will not be revealed during REPL tab completion.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.ReciprocalBasis","page":"Lattices","title":"Electrum.ReciprocalBasis","text":"Electrum.LatticeBasis{S<:Electrum.BySpace,D,T} <: StaticMatrix{D,D,T}\n\nRepresents the basis vectors of a D-dimensional lattice in real or reciprocal space, depending on S. The units of LatticeBasis{Electrum.ByRealSpace} are bohr, and those of LatticeBasis{Electrum.ByReciprocalSpace} are rad*bohr⁻¹, corresponding to the convention that the dot product of a real space basis vector with a reciprocal space basis vector is 2π.\n\nType aliases\n\nFor convenience, the type aliases RealBasis and ReciprocalBasis are defined below:\n\nconst RealBasis = LatticeBasis{ByRealSpace}\nconst ReciprocalBasis = LatticeBasis{ByReciprocalSpace}\nconst AbstractBasis = LatticeBasis{<:BySpace}\n\nThese type aliases are exported, and in most circumstances code should refer to these types for the sake of readability, not Electrum.LatticeBasis, which is unexported.\n\nMathematical operations\n\nElectrum.LatticeBasis behaves as an ordinary matrix and should support all mathematical operations commonly used, including left division with vectors (\\), commonly used in the conversion between Cartesian and fractional (reduced) coordinates.\n\nIn most cases, matrix multiplications will convert the result to an ordinary StaticArray or Array. However, right multiplications of an Electrum.LatticeBasis{S,D} with an  SMatrix{D,D,<:Integer} are treated as the application of a supercell building operation, and  return a new Electrum.LatticeBasis{S,D} instead.\n\nConversion\n\nA RealBasis may be converted to a ReciprocalBasis, or vice versa, using either convert(T::Electrum.LatticeBasis, b) or the constructor (T::Type{<:Electrum.LatticeBasis})(b). This automatically multiplies or divides by 2π as needed.\n\nThe inverse operation inv also performs this conversion. This convention may change in a future update, as the current definition may break other assumptions about matrix inversion.\n\nInteroperability\n\nFile import and export methods in Electrum and any other software which returns these types must perform unit conversion if the units used by the other software package are different.\n\nInternals\n\nIn order to avoid the presence of an extraneous type parameter, the backing vectors field of a LatticeBasis is not an SMatrix{D,D,T} (as this is not a concrete type), but an  SVector{D,SVector{D,T}}. However, the property matrix is defined so that it returns an SMatrix{D,D,T}. The vectors property is private, and will not be revealed during REPL tab completion.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.AbstractBasis","page":"Lattices","title":"Electrum.AbstractBasis","text":"Electrum.LatticeBasis{S<:Electrum.BySpace,D,T} <: StaticMatrix{D,D,T}\n\nRepresents the basis vectors of a D-dimensional lattice in real or reciprocal space, depending on S. The units of LatticeBasis{Electrum.ByRealSpace} are bohr, and those of LatticeBasis{Electrum.ByReciprocalSpace} are rad*bohr⁻¹, corresponding to the convention that the dot product of a real space basis vector with a reciprocal space basis vector is 2π.\n\nType aliases\n\nFor convenience, the type aliases RealBasis and ReciprocalBasis are defined below:\n\nconst RealBasis = LatticeBasis{ByRealSpace}\nconst ReciprocalBasis = LatticeBasis{ByReciprocalSpace}\nconst AbstractBasis = LatticeBasis{<:BySpace}\n\nThese type aliases are exported, and in most circumstances code should refer to these types for the sake of readability, not Electrum.LatticeBasis, which is unexported.\n\nMathematical operations\n\nElectrum.LatticeBasis behaves as an ordinary matrix and should support all mathematical operations commonly used, including left division with vectors (\\), commonly used in the conversion between Cartesian and fractional (reduced) coordinates.\n\nIn most cases, matrix multiplications will convert the result to an ordinary StaticArray or Array. However, right multiplications of an Electrum.LatticeBasis{S,D} with an  SMatrix{D,D,<:Integer} are treated as the application of a supercell building operation, and  return a new Electrum.LatticeBasis{S,D} instead.\n\nConversion\n\nA RealBasis may be converted to a ReciprocalBasis, or vice versa, using either convert(T::Electrum.LatticeBasis, b) or the constructor (T::Type{<:Electrum.LatticeBasis})(b). This automatically multiplies or divides by 2π as needed.\n\nThe inverse operation inv also performs this conversion. This convention may change in a future update, as the current definition may break other assumptions about matrix inversion.\n\nInteroperability\n\nFile import and export methods in Electrum and any other software which returns these types must perform unit conversion if the units used by the other software package are different.\n\nInternals\n\nIn order to avoid the presence of an extraneous type parameter, the backing vectors field of a LatticeBasis is not an SMatrix{D,D,T} (as this is not a concrete type), but an  SVector{D,SVector{D,T}}. However, the property matrix is defined so that it returns an SMatrix{D,D,T}. The vectors property is private, and will not be revealed during REPL tab completion.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Methods","page":"Lattices","title":"Methods","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.eachvertex\nElectrum.basis\nBase.inv(::Electrum.LatticeBasis)\nElectrum.dual\nElectrum.dualbasis\nElectrum.lengths(::Electrum.LatticeBasis)\nElectrum.volume(::Electrum.LatticeBasis)\nElectrum.angles_cos\nElectrum.angles_rad\nElectrum.angles_deg\nElectrum.gram\nElectrum.triangularize\nElectrum.maxHKLindex","category":"page"},{"location":"api/lattices.html#Electrum.eachvertex","page":"Lattices","title":"Electrum.eachvertex","text":"eachvertex([m::AbstractMatrix], r::AbstractArray...)\n\nReturns an iterator of SVector{size(r),eltype(r)} objects representing each vertex whose reduced coordinates lie in ranges r. If no matrix is given, the iterator generates all vectors whose coordinates are in corresponding arrays r. A supplied matrix will be left-multiplied with these vectors to generate Cartesian representation of those vectors.\n\n\n\n\n\neachvertex(b::StaticMatrix)\neachvertex(b::AbstractMatrix)\n\nReturns an iterator of AbstractVector objects corresponding to each vertex of the parallelepiped spanned by the column vectors of b.\n\nIn the case of StaticMatrix subtypes, this function returns SVector objects, allowing for efficient collection into an Array{SVector{D},D}, preserving the arrangement of the vertices in space. However, for other AbstractMatrix objects whose sizes are not known at compile time, the iterator can only be collected into a Vector{<:Vector} to preserve type stability. We generally recommend working with static matrix types like the provided RealBasis and ReciprocalBasis.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.basis","page":"Lattices","title":"Electrum.basis","text":"basis(x)\n\nReturns the lattice basis associated with a data structure. By default, this returns  getproperty(x, :basis). This may be implemented for custom data types by either adding a method to basis() or by defining custom getproperty() and propertynames() methods.\n\nAlthough basis(x) should always return an Electrum.LatticeBasis, the exact return type may vary: not only can the numeric type vary, some data strucutres may store a real space lattice, and others may store a reciprocal space lattice, allowing for properties of the data contained to be inferred. For predictable results, use convert(T, basis(x)) where T is the desired type.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Base.inv-Tuple{Electrum.LatticeBasis}","page":"Lattices","title":"Base.inv","text":"inv(b::LatticeBasis{D}) -> SMatrix{D,D}\n\nReturns the matrix which, when left or right multiplied by b, returns the identity matrix, up to rounding error. Because the result of this calculation is not the dual lattice associated with b, the return type is simply an SMatrix{D,D}.\n\nFor the dual space lattice basis vectors, use dual(x) or dualbasis(x).\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.dual","page":"Lattices","title":"Electrum.dual","text":"dual(b::RealBasis) -> ReciprocalBasis\ndual(b::ReciprocalBasis) -> RealBasis\n\nReturns the basis of the dual lattice, which is the lattice in dual space whose product with the original lattice is equal to the identity matrix multiplied by 2π.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.dualbasis","page":"Lattices","title":"Electrum.dualbasis","text":"dualbasis(x)\n\nReturns the dual basis associated with a data structure x; equal to dual(basis(x)).\n\nThis function should never be defined directly: instead, basis(::T) should be implemented for a custom type T.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.lengths-Tuple{Electrum.LatticeBasis}","page":"Lattices","title":"Electrum.lengths","text":"lengths(b::LatticeBasis{S,D}) -> SVector{D}\n\nReturns the lengths of the basis vectors. The units correspond to the type of the basis vectors: for RealBasis the units are bohr, and for ReciprocalBasis the units are rad*bohr⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.volume-Tuple{Electrum.LatticeBasis}","page":"Lattices","title":"Electrum.volume","text":"volume(b::LatticeBasis) -> Real\n\nReturns the volume of a unit cell defined by a matrix. This volume does not carry the sign (negative for cells that do not follow the right hand rule). The units correspond to the type of the basis  vectors: for RealBasis the units are bohr³, and for ReciprocalBasis the units are rad³*bohr⁻³.\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.angles_cos","page":"Lattices","title":"Electrum.angles_cos","text":"angles_cos(b::LatticeBasis{S,D}) -> SVector{binomial(D,2)}\n\nGenerates the cosines of the unit cell angles.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_rad","page":"Lattices","title":"Electrum.angles_rad","text":"angles_rad(b::LatticeBasis{S,D}) -> SVector{binomial(D,2)}\n\nReturns the angles (in radians) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_deg","page":"Lattices","title":"Electrum.angles_deg","text":"angles_deg(b::LatticeBasis{S,D}) -> SVector{binomial(D,2)}\n\nReturns the angles (in degrees) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.gram","page":"Lattices","title":"Electrum.gram","text":"gram(b::LatticeBasis{S,D}) -> SMatrix{D,D}\n\nReturns the Gram matrix associated with a set of basis vectors. The entries of this matrix are the dot products associated with all possible combinations of basis vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.triangularize","page":"Lattices","title":"Electrum.triangularize","text":"triangularize(l::T) where T<:LatticeBasis -> T\n\nConverts a set of basis vectors to an upper triangular form using QR decomposition.\n\n\n\n\n\ntriangularize(l::T, sc::AbstractMatrix{<:Integer}) where T<:LatticeBasis -> T\n\nConverts a set of basis vectors to an upper triangular form using QR decomposition, with an included conversion to a larger supercell. The resulting matrix that describes the basis vectors will have only positive values along the diagonal, and therefore, is always right-handed (regardless of the transformation matrix used).\n\nLAMMPS expects that basis vectors are given in this format.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.maxHKLindex","page":"Lattices","title":"Electrum.maxHKLindex","text":"Electrum.maxHKLindex(b::LatticeBasis, ecut::Real; prim=true, c = 2)\n\nDetermines the maximum integer values of the reciprocal lattice vectors needed to store data out to a specific energy cutoff for a 3D lattice.\n\nBy default, the energy cutoff is assumed to be in units of Hartree, the reciprocal lattice vector lengths are assumed to be in radbohr⁻¹, and the value of c is that of the constant (2mₑ/ħ²). In Hartree atomic units, this value is 2 - but for VASP WAVECAR outputs, the value is given in  eV⁻¹angstrom⁻² - see Electrum.CVASP for more information.\n\nThe functionality implemented here was taken from WaveTrans: https://www.andrew.cmu.edu/user/feenstra/wavetrans/\n\n\n\n\n\n","category":"function"},{"location":"index.html#Electrum.jl","page":"Home","title":"Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package that provides structs and methods for working with crystal structures.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is a package designed to make the development of chemical theory tools easier. Not only does it offer a type system that handles data commonly used in theory (such as real and reciprocal space data grids), it also offers broad support for file types common to chemical theory.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the future, we aim to support native Julia plotting of data processed by this package with a  separate package that provides bindings to commonly used plotting utilities.","category":"page"},{"location":"index.html#Getting-Electrum.jl","page":"Home","title":"Getting Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As of this release, Electrum.jl is not in the Julia package registry. You'll need to manually add this repo to your Julia environment (which should be at least v1.6, and ideally the current release version):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.6+ pkg)> add https://github.com/brainandforce/Electrum.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also do this by importing Pkg and entering the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\")","category":"page"},{"location":"index.html#Tracking-different-branches","page":"Home","title":"Tracking different branches","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you'd like to work on developing Electrum.jl, you probably want to work on the project's current  state, and not the release version. You can do this by specifying the branch you want to track (let's assume it's next):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.6+) pkg> add https://github.com/brainandforce/Electrum.jl#next","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\", rev=\"next\")","category":"page"},{"location":"index.html#Licensing-and-attribution","page":"Home","title":"Licensing and attribution","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is MIT licensed. In short, this means that you can use this package however you like, without restrictions on relicensing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You are not required to cite this package if you use it in research, however, attribution is always appreciated. This is facilitated by the CITATION.cff file included in the repository.","category":"page"},{"location":"api/atoms.html#Atoms","page":"Atoms","title":"Atoms","text":"","category":"section"},{"location":"api/atoms.html#Constructors-and-types","page":"Atoms","title":"Constructors and types","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.NamedAtom\nElectrum.AbstractAtomPosition\nElectrum.CartesianAtomPosition\nElectrum.FractionalAtomPosition\nElectrum.AbstractAtomList\nElectrum.AtomList\nElectrum.PeriodicAtomList","category":"page"},{"location":"api/atoms.html#Electrum.NamedAtom","page":"Atoms","title":"Electrum.NamedAtom","text":"NamedAtom\n\nStores information about an atom, which includes a name which may be up to 15 codepoints long, and the atomic number.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomPosition","page":"Atoms","title":"Electrum.AbstractAtomPosition","text":"AbstractAtomPosition{D}\n\nSupertype that describes atomic positions in D dimensions, which include name, coordinate, and occupancy information.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.CartesianAtomPosition","page":"Atoms","title":"Electrum.CartesianAtomPosition","text":"CartesianAtomPosition{D}\n\nDescribes an absolute atomic position. The coordinate in the pos field is assumed to be given in bohr.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.FractionalAtomPosition","page":"Atoms","title":"Electrum.FractionalAtomPosition","text":"FractionalAtomPosition{D}\n\nDescribes an atomic position within a crystal or other periodic structure. The coordinate in the pos field is assumed to be given relative to the basis vectors of the structure.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomList","page":"Atoms","title":"Electrum.AbstractAtomList","text":"AbstractAtomList{D}\n\nSupertype for lists of atomic positions in D dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AtomList","page":"Atoms","title":"Electrum.AtomList","text":"AtomList{D}\n\nContains a list of CartesianAtomPosition objects, corresponding to atoms in free space without boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.PeriodicAtomList","page":"Atoms","title":"Electrum.PeriodicAtomList","text":"PeriodicAtomList{D}\n\nContains a list of FractionalAtomPosition objects with an associated basis, corresponding to atoms in a system with periodicity.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Extracting-data","page":"Atoms","title":"Extracting data","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.name\nElectrum.atomic_number\nElectrum.isdummy\nElectrum.atomtypes\nElectrum.natomtypes\nElectrum.atomcounts\nBase.isapprox(::T, ::T) where T<:AbstractAtomPosition\nElectrum.distance(::CartesianAtomPosition, ::CartesianAtomPosition)","category":"page"},{"location":"api/atoms.html#Electrum.name","page":"Atoms","title":"Electrum.name","text":"name(a::NamedAtom) -> String\n\nReturns the name associated with a NamedAtom. For atoms constructed with only an atomic number, the name will be the atomic symbol. This function returns a Base.String for compatibility, not the InlineStrings.InlineString15 from the backing field.\n\nExamples\n\njulia> a = NamedAtom(\"Cl1\", 17)\nNamedAtom(\"Cl1\", 17)\n\njulia> name(a)\n\"Cl1\"\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.atomic_number","page":"Atoms","title":"Electrum.atomic_number","text":"atomic_number(a::NamedAtom)\n\nReturns the atomic number associated with a NamedAtom. For atoms constructed with only a name, the atomic number returned will be that associated with the symbol if the symbol exactly corresponds to an atom name.\n\nExamples\n\njulia> a = NamedAtom(\"Cl1\", 17)\nNamedAtom(\"Cl1\", 17)\n\njulia> atomic_number(a)\n17\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.isdummy","page":"Atoms","title":"Electrum.isdummy","text":"isdummy(a::NamedAtom) -> Bool\n\nReturns true if the atomic number of a NamedAtom is zero, false otherwise. Atoms with zero as the atomic number are treated as dummy atoms, which may be used to reference specific positions in a molecule or crystal.\n\nExamples\n\njulia> a = NamedAtom(\"Cl1\", 17)\nNamedAtom(\"Cl1\", 17)\n\njulia> b = NamedAtom(\"test\")\nNamedAtom(\"test\", 0)\n\njulia> isdummy(a)\nfalse\n\njulia> isdummy(b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.atomtypes","page":"Atoms","title":"Electrum.atomtypes","text":"atomtypes(l::AbstractAtomList; dummy=false) -> Vector{NamedAtom}\n\nReturns all unique NamedAtom types found in an AbstractAtomList. This vector is sorted by atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nTo obtain a list of all unique atom names or atomic numbers, use name.(atomtypes(l)) or num.(atomtypes(l)).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.natomtypes","page":"Atoms","title":"Electrum.natomtypes","text":"natomtypes(l::AbstractAtomList; dummy=false) -> Int\n\nReturns the number of types of atoms in an AbstractAtomList.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.atomcounts","page":"Atoms","title":"Electrum.atomcounts","text":"atomcounts(l::AbstractAtomList; dummy=false, names=false) -> Vector{Pair{NamedAtom,Int}}\n\nReturns pairs of atoms and the number of atoms in the AtomList with that atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Base.isapprox-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractAtomPosition","page":"Atoms","title":"Base.isapprox","text":"isapprox(a::AbstractAtomPosition, b::AbstractAtomPosition; atol = sqrt(eps(Float64)))...)\n\nChecks whether two atomic sites are approximately equal to one another. The function returns true if the atomic numbers of the atoms are the same, and the coordinates of the atoms differ by no more than atol. \n\n\n\n\n\n","category":"method"},{"location":"api/atoms.html#Electrum.distance-Tuple{CartesianAtomPosition, CartesianAtomPosition}","page":"Atoms","title":"Electrum.distance","text":"distance(a1::CartesianAtomPosition, a2::CartesianAtomPosition) -> Float64    \ndistance(b::LatticeBasis, a1::FractionalAtomPosition, a2::FractionalAtomPosition) -> Float64\n\nCalculates the distance between two FractionalAtomPosition objects in the same basis b.\n\n\n\n\n\n","category":"method"},{"location":"api/atoms.html#Moving-and-processing-atom-lists","page":"Atoms","title":"Moving and processing atom lists","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.deduplicate\nElectrum.move_into_cell\nElectrum.supercell","category":"page"},{"location":"api/atoms.html#Electrum.deduplicate","page":"Atoms","title":"Electrum.deduplicate","text":"deduplicate(l::AbstractVector{T<:AbstractAtomPosition}; atol=sqrt(eps(Float64))) -> Vector{T}\ndeduplicate(l::AbstractAtomList; atol=sqrt(eps(Float64))) -> <:AbstractAtomList\n\nRemoves atoms that are duplicates or close to being duplicates. In order to be considered duplicates, the atoms must have both the atomic number, and their coordinates must be approximately equal (to within a total distance of sqrt(eps(Float64))).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.move_into_cell","page":"Atoms","title":"Electrum.move_into_cell","text":"move_into_cell(l::AbstractVector{T<:FractionalAtomPosition}; atol=sqrt(eps(Float64)))\n    -> Vector{T}\nmove_into_cell(l::PeriodicAtomList; atol=sqrt(eps(Float64))) -> PeriodicAtomList\n\nMoves atoms that may exist outside of the bounds of a unit cell (meaning that their fractional coordinates are not between 0 and 1) into the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.supercell","page":"Atoms","title":"Electrum.supercell","text":"supercell(l::PeriodicAtomList, M) -> PeriodicAtomList\n\nCreates a new AtomList with the basis vectors of a supercell generated by transforming the basis  vectors of the space by M, which may be an integer matrix, an integer vector which is treated as a diagonal matrix, or a plain integer, which performs a uniform scaling. This function will also generate new atomic positions to fill the cell.\n\nThe function performs this transformation by calculating the Smith normal form of the transformation matrix. This matrix provides the integer scaling factors needed to stretch the supercell, and the left unimodular factor is then used to perform the final transformation.\n\n\n\n\n\n","category":"function"},{"location":"atoms.html#Atoms","page":"Atoms and crystals","title":"Atoms","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Once a lattice is defined, we can include other data, and atomic coordinates are one of the most common datasets encountered.","category":"page"},{"location":"atoms.html#NamedAtom","page":"Atoms and crystals","title":"NamedAtom","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"A NamedAtom contains two pieces of information: an atom name and the associated atomic number. The atom name is a string no longer than 15 codepoints (internally, we use  InlineStrings.InlineString15 to store this data), and the atomic number is an Int.","category":"page"},{"location":"atoms.html#Constructors","page":"Atoms and crystals","title":"Constructors","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"The default constructor for NamedAtom is NamedAtom(::AbstractString, ::Integer). The atom name can be inferred and specified automatically as the associated symbol if only a number is given.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"In the case of only a string being provided, the atomic number may be inferred. This is done by matching the first letters up to a non-letter character of the string with a known symbol. If no match is found, the atomic number will be 0, corresponding to a dummy atom (see below).","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"note: Note\nSupport for inferring from symbols representing unnamed elements or atomic numbers of those elements (for instance, element 119, Uue) is not yet implemented.","category":"page"},{"location":"atoms.html#Sorting","page":"Atoms and crystals","title":"Sorting","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"NamedAtom types are sorted by atomic number first, then by name.","category":"page"},{"location":"atoms.html#Dummy-atoms","page":"Atoms and crystals","title":"Dummy atoms","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Sometimes, it is useful to include dummy atoms: sites which do not correspond to a real atomic position, but are useful to track in certain circumstances. Dummy atoms have atomic number zero.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"If no string is provided, NamedAtom(0) returns NamedAtom(\"dummy\", 0), as does any argument not between 1 and 118.","category":"page"},{"location":"atoms.html#Atomic-positions","page":"Atoms and crystals","title":"Atomic positions","text":"","category":"section"},{"location":"atoms.html#Atom-position-data","page":"Atoms and crystals","title":"Atom position data","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Atomic positions are given by a CartesianAtomPosition{D} for Cartesian coordinates, or a FractionalAtomPosition{D} for fractional coordinates with respect to a lattice. This information consists of a NamedAtom, a coordinate in real space as an SVector{D,Float64}, and optional occupancy data for partially occupied sites - if not specified, it defaults to 1 (fully occupied).","category":"page"},{"location":"atoms.html#Lists-of-atomic-positions","page":"Atoms and crystals","title":"Lists of atomic positions","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"The AbstractAtomList{D} type represents a list of atoms.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"AtomList{D} is a wrapper for Vector{CartesianAtomPosition{D}}, and represents atomic positions in an arbitrary D-dimensional space.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"PeriodicAtomList{D} wraps Vector{FractionalAtomPosition{D}}, but also includes the basis vectors of the lattice associated with fractional coordinates.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"The two types can be interconverted with the appropriate constructors. An AtomList can be constructed from a PeriodicAtomList directly, but for the reverse conversion, the basis vectors of the new PeriodicAtomList must be specified.","category":"page"},{"location":"atoms.html#Sorting-2","page":"Atoms and crystals","title":"Sorting","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Structures often have many identical NamedAtom instances, so sorting of FractionalAtomPosition and CartesianAtomPosition is accomplished by whichever has the lowest initial coordinate, moving to the next coordinate in the case of ties.","category":"page"},{"location":"atoms.html#Constructing-supercells","page":"Atoms and crystals","title":"Constructing supercells","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"In many cases, it is useful to construct a supercell from a unit cell. This can be done to convert a primitive cell to a conventional representation, or to a cell of a larger size or different shape.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"The supercell(::PeriodicAtomList, ::AbstractMatrix{<:Integer}) function takes an AbstractMatrix{<:Integer}, which transforms the lattice basis vectors by right multiplication, and fills the new lattice with copies of atoms from the original cell. Scalar arguments (calling supercell(::PeriodicAtomList, ::Integer)) scale each direction by the identity matrix multiplied by the scalar, and vector arguments (calling supercell(::PeriodicAtomList, ::Integer)) convert the vector to a diagonal matrix.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Internally, this is done using the [Smith normal form][1] of the transformation matrix, using the diagonal factors to extend the lattice the correct number of times along specific dimensions, and moving them into the cell with the help of the unimodular factors associated with the Smith normal form.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Electrum.supercell","category":"page"},{"location":"atoms.html#Electrum.supercell-atoms","page":"Atoms and crystals","title":"Electrum.supercell","text":"supercell(l::PeriodicAtomList, M) -> PeriodicAtomList\n\nCreates a new AtomList with the basis vectors of a supercell generated by transforming the basis  vectors of the space by M, which may be an integer matrix, an integer vector which is treated as a diagonal matrix, or a plain integer, which performs a uniform scaling. This function will also generate new atomic positions to fill the cell.\n\nThe function performs this transformation by calculating the Smith normal form of the transformation matrix. This matrix provides the integer scaling factors needed to stretch the supercell, and the left unimodular factor is then used to perform the final transformation.\n\n\n\n\n\n","category":"function"},{"location":"atoms.html#Crystals","page":"Atoms and crystals","title":"Crystals","text":"","category":"section"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"The Crystal{D} represents a generating set of atomic positions for a periodic structure. Along with a PeriodicAtomList, a Crystal{D} contains the space group and origin setting associated with the data, as well as an integer matrix transformation describing the unit cell generated by the given cell. The set_transform! function allows for the transformation matrix to be altered  after the creation of a Crystal{D} object.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"This data can be converted to a PeriodicAtomList{D} with a constructor or Base.convert call, and this uses the supercell function to construct the full list of atoms from the generating set.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"warning: Warning\nAt the moment, the use of space group data to generate atomic sites is not yet implemented. A space group number and setting may be provided, but this will not be used to generate any atomic sites. ","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"Additionally, we provide the CrystalWithDatasets{D,K,V}, which associates a Crystal{D} with a Dict{K,V} containing datasets associated with the structure. This data structure may be indexed like the underlying dictionary.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"note: Note\nCrystalWithDatasets{D,K,V} will likely be changed significantly or removed in Electrum 0.2.","category":"page"},{"location":"atoms.html","page":"Atoms and crystals","title":"Atoms and crystals","text":"[1]: https://en.wikipedia.org/wiki/Smithnormalform","category":"page"}]
}
