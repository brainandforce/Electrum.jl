var documenterSearchIndex = {"docs":
[{"location":"api/filetypes.html#File-types","page":"File formats","title":"File types","text":"","category":"section"},{"location":"api/filetypes.html#Miscellaneous","page":"File formats","title":"Miscellaneous","text":"","category":"section"},{"location":"api/filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readXYZ\nElectrum.readXSF\nElectrum.readCPcoeff\nElectrum.readCPgeo\nElectrum.readCPcell","category":"page"},{"location":"api/filetypes.html#Electrum.readXYZ","page":"File formats","title":"Electrum.readXYZ","text":"readXYZ(io::IO) -> AtomList{3}\n\nReads an XYZ file into an AtomList{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readXSF","page":"File formats","title":"Electrum.readXSF","text":"readXSF3D(\n    io::IO;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads in an XCrysDen XSF file from an input stream and returns a CrystalWithDatasets{3} with all datasets that have been included within the file.\n\nSpace group and origin information are not supplied in XSF files, but they can be supplied using the spgrp and origin keyword arguments. Centering information can be provided using the ctr  argument, but is overridden by a space group assignment.\n\n\n\n\n\nreadXSF3D(\n    file;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads an XSF file at path filename.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcoeff","page":"File formats","title":"Electrum.readCPcoeff","text":"readCPcoeff(file, Lmax::Val{L}=Val{6}()) -> SphericalComponents{L}\n\nReads in the spherical harmonic projection coefficients from a CPpackage2 calculation.\n\nBy default, CPpackage2 gives the coefficients for spherical harmonics up to a maximum l value of 6.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPgeo","page":"File formats","title":"Electrum.readCPgeo","text":"readCPgeo(file) -> Vector{AtomPosition{3}}\n\nReads the atomic positions used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcell","page":"File formats","title":"Electrum.readCPcell","text":"readCPcell(file) -> RealBasis{3}\n\nReads the basis vectors of the unit cell used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Reading-2","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writeXYZ\nElectrum.writeXSF","category":"page"},{"location":"api/filetypes.html#Electrum.writeXYZ","page":"File formats","title":"Electrum.writeXYZ","text":"writeXYZ(io::IO, data::AbstractVector{<:AbstractAtomPosition})\nwriteXYZ(io::IO, data::AbstractAtomList)\nwriteXYZ(io::IO, data::AbstractCrystal)\n\nWrite an XYZ file based on a set of atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.writeXSF","page":"File formats","title":"Electrum.writeXSF","text":"writeXSF(io, xtal::PeriodicAtomList{D})\n\nWrites the crystal component of an XCrysDen XSF file.\n\n\n\n\n\nwriteXSF(io::IO, key, data::RealSpaceDataGrid{D,T}; periodic=true)\n\nWrites the crystal component of an XCrysDen XSF file. By default, automatic wrapping of the datagrid occurs (values are repeated at the end of each dimension).\n\n\n\n\n\nwriteXSF(io::IO, xtaldata::CrystalWithDatasets{D,K,V})\n\nWrites a CrystalWithDatasets to an XCrysDen XSF file.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#ABINIT-files","page":"File formats","title":"ABINIT files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-3","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.read_abinit_density\nElectrum.read_abinit_potential\nElectrum.read_abinit_wavefunction","category":"page"},{"location":"api/filetypes.html#Electrum.read_abinit_density","page":"File formats","title":"Electrum.read_abinit_density","text":"read_abinit_density(file)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,Float64}}\n\nReads a FORTRAN binary formatted abinit density file. By default, abinit density files will have the suffix DEN, but no assumptions are made about suffixes.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin densities.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_potential","page":"File formats","title":"Electrum.read_abinit_potential","text":"read_abinit_potential(file)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,T}} where T<:Union{Float64,ComplexF64}\n\nReads a FORTRAN binary formatted abinit potential file.\n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_wavefunction","page":"File formats","title":"Electrum.read_abinit_wavefunction","text":"read_abinit_wavefunction(file)\n    -> CrystalWithDatasets{3,String,ReciprocalWavefunction{3,Float64}}\n\nReads a FORTRAN binary formatted abinit potential file. \n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#VASP-files","page":"File formats","title":"VASP files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-4","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readDOSCAR\nElectrum.readKPOINTS\nElectrum.readPOSCAR\nElectrum.readPROCAR\nElectrum.readWAVECAR","category":"page"},{"location":"api/filetypes.html#Electrum.readDOSCAR","page":"File formats","title":"Electrum.readDOSCAR","text":"readDOSCAR(file) -> Tuple{DensityOfStates, Vector{ProjectedDensityOfStates}}\n\nReads a DOSCAR file from VASP and returns its data as a tuple containing the total and projected density of states (if present).\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readKPOINTS","page":"File formats","title":"Electrum.readKPOINTS","text":"readKPOINTS(file) -> KPointGrid{3}\n\nReads a KPOINTS file to get the k-point mesh. Currently, it only supports grid-generated meshes.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPOSCAR","page":"File formats","title":"Electrum.readPOSCAR","text":"readPOSCAR(file) -> PeriodicAtomList{3}\nreadCONTCAR(file) -> PeriodicAtomList{3}\n\nReads a VASP POSCAR or CONTCAR file.\n\nA POSCAR contains the basis vectors of the system (potentially given with a scaling factor), the positions of all atoms as either Cartesian or reduced coordinates, and potentially information needed to perform an ab initio MD run.\n\nA CONTCAR file is written at the end of a VASP run and contains the atomic coordinates after the calculation completed. This is relevant for geometry optimizations.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPROCAR","page":"File formats","title":"Electrum.readPROCAR","text":"readPROCAR(file) -> FatBands{3}\n\nReads an lm-decomposed PROCAR file from VASP and returns its data as a FatBands{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readWAVECAR","page":"File formats","title":"Electrum.readWAVECAR","text":"readWAVECAR(file) -> ReciprocalWavefunction{3,Float32}\n\nReads a WAVECAR file output from a VASP 4.6 calcuation.\n\nInformation about VASP WAVECAR files and much of the code was pulled from the WaveTrans website (originally written in FORTRAN): https://www.andrew.cmu.edu/user/feenstra/wavetrans/\n\nThis function is limited to WAVECAR files which have an RTAG value of 45200 (meaning the data is given as a Complex{Float32}) and have only a collinear magnetic field applied, like WaveTrans. It should also be noted that the weights of the k-points are not present in the WAVECAR file, and are set to 1 by default.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writePOSCAR4","category":"page"},{"location":"api/filetypes.html#Electrum.writePOSCAR4","page":"File formats","title":"Electrum.writePOSCAR4","text":"writePOSCAR4(file, data; kwargs...)\n\nWrites crystal data to a VASP 4.6 POSCAR output. The data can be a PeriodicAtomList or an AbstractCrystal.\n\nBy default, atom names are not written (since this seems to break VASP 4.6) but this may be overridden by setting names to true (which prevents VESTA from crashing). Dummy atoms are not are not written by default, but they may be written by setting dummy=true.\n\nThe first line, normally used to describe the system, may be altered by passing a printable object to comment.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"api/filetypes.html#Reading-5","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html#Writing-2","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.write_lammps_data","category":"page"},{"location":"api/filetypes.html#Electrum.write_lammps_data","page":"File formats","title":"Electrum.write_lammps_data","text":"write_lammps_data(io::IO, list::PeriodicAtomList, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for running a molecular dynamics simulation. \n\nIf transform is supplied, the list of atoms will be converted to a supercell with the associated transformation (either a matrix, vector, or scalar). The dummy keyword determines whether dummy atoms are included in the output (false by default).\n\nThis function currently only works for 3D systems.\n\n\n\n\n\nwrite_lammps_data(io::IO, xtal::AbstractCrystal, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for for running a molecular dynamics simulation. \n\nThe list of atoms that is written is given by converting xtal to a PeriodicAtomList, which uses the supplied transformation matrix to generate all atomic positions. If transform is supplied, the transformation will be applied to the PeriodicAtomList - it does not replace the transform provided with xtal.\n\nThis function currently only works for 3D systems.\n\n\n\n\n\nwrite_lammps_data(file, data, [transform]; dummy::Bool = false)\n\nWrites a LAMMPS data file to the path given by filename.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Crystal-data","page":"Crystal data","title":"Crystal data","text":"","category":"section"},{"location":"api/data.html#General","page":"Crystal data","title":"General","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.lengths(::Any)\nElectrum.volume(::Any)\nElectrum.basis(::Any)\nElectrum.AbstractDataGrid","category":"page"},{"location":"api/data.html#Electrum.lengths-Tuple{Any}","page":"Crystal data","title":"Electrum.lengths","text":"lengths(b::AbstractBasis) -> Vector{Float64}\n\nReturns the lengths of the basis vectors.\n\n\n\n\n\nlengths(x) -> Float64\n\nCalculate the lengths of the basis vectors associated with x. These will be real space lengths (assumed to be in angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.volume-Tuple{Any}","page":"Crystal data","title":"Electrum.volume","text":"volume(x) -> Float64\n\nCalculate the volume of the basis associated with x. This will be a real space volume (assumed to be in cubic angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.basis-Tuple{Any}","page":"Crystal data","title":"Electrum.basis","text":"basis(x) -> AbstractBasis\n\nReturns the basis associated with some data in x. By default, it's assumed to be accessible via the property :basis.\n\nThe return value might be a RealBasis or a ReciprocalBasis, depending on the space in which data is represented. Use RealBasis(g) or ReciprocalBasis(g) if a specific type is needed.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.AbstractDataGrid","page":"Crystal data","title":"Electrum.AbstractDataGrid","text":"AbstractDataGrid{D,T}\n\nSupertype for crystal data associated with a grid of entries of type T in real or reciprocal space of dimension D.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Real-space","page":"Crystal data","title":"Real space","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.RealSpaceDataGrid\nElectrum.voxelsize\nElectrum.integrate\nElectrum.fft","category":"page"},{"location":"api/data.html#Electrum.RealSpaceDataGrid","page":"Crystal data","title":"Electrum.RealSpaceDataGrid","text":"RealSpaceDataGrid{D,T} <: AbstractDataGrid{D,T}\n\nA data grid defined in real space, containing data of type T.\n\nBy convention, indexing of RealSpaceDataGrid is zero-based. This convention is used so that datasets where the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.voxelsize","page":"Crystal data","title":"Electrum.voxelsize","text":"voxelsize(g::RealSpaceDataGrid) -> Float64\n\nGets the size of a single voxel of a RealSpaceDataGrid.\n\nBy default, units are assumed to be cubic angstroms.\n\n\n\n\n\nvoxelsize(g::HKLData)\n\nGets the size of a voxel asssociated with the RealSpaceDataGrid that would be generated by  performing an inverse Fourier transform on the HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.integrate","page":"Crystal data","title":"Electrum.integrate","text":"integrate(g::RealSpaceDataGrid{D,T}) -> T\n\nPerforms an integration across all voxels, returning a scalar value.\n\n\n\n\n\nintegrate(f::Function, g::RealSpaceDataGrid{D,T}) -> T\n\nApplies the function f pointwise to the elements of a datagrid, then integrates the grid across all voxels.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.fft","page":"Crystal data","title":"AbstractFFTs.fft","text":"fft(g::RealSpaceDataGrid) -> HKLData\n\nPerforms a fast Fourier transform on the data in a RealSpaceDataGrid and returns an HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Reciprocal-space","page":"Crystal data","title":"Reciprocal space","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.AbstractReciprocalSpaceData\nElectrum.AbstractKPointSet\nElectrum.KPointGrid\nElectrum.KPointList\nElectrum.BandAtKPoint\nElectrum.BandStructure\nElectrum.FatBands\nElectrum.HKLData\nElectrum.HKLDict\nElectrum.ReciprocalWavefunction\nElectrum.nkpt\nElectrum.nband\nElectrum.ifft","category":"page"},{"location":"api/data.html#Electrum.AbstractKPointSet","page":"Crystal data","title":"Electrum.AbstractKPointSet","text":"AbstractKPointSet{D}\n\nSupertype for sets of k-points in D dimensions, either provided as explicit lists or as a generator (such as a matrix defining a mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.BandAtKPoint","page":"Crystal data","title":"Electrum.BandAtKPoint","text":"BandAtKPoint\n\nStores information about a band's energy and its occupancy at a specific k-point.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.BandStructure","page":"Crystal data","title":"Electrum.BandStructure","text":"BandStructure{D}\n\nStores information about an electronic band structure, including the list of k-points used to generate the data (as a KPointMesh{D})and the band information at every k-point (as a Vector{BandAtKPoint}).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.FatBands","page":"Crystal data","title":"Electrum.FatBands","text":"FatBands{D}\n\nStores information relevant to plotting fatbands.\n\nFatBands.bands: matrix of energies at each [kpt, band].\nFatBands.projband: array of lm-decomposed band structure. [orbital, ion, band, kpt].\nFatBands.cband: array of complex-valued contributions to band structure.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.HKLData","page":"Crystal data","title":"Electrum.HKLData","text":"HKLData{D,T} <: AbstractDataGrid{D,T}\n\nStores information associated with a reciprocal space basis. Data can be accessed and modified by using the G-vectors as indices. Associated k-point data is also provided; if no k-point is supplied it is assumed to be the gamma point (zero(SVector{D,Float64}))\n\nInternally, the data is stored such that the zero frequency components are at the first indices along that dimension. The data at G-vector [0, 0, 0] is stored in the backing array's [1, 1, 1] index, and the rest of the indices correspond to reciprocal space points using the FFT convention.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.HKLDict","page":"Crystal data","title":"Electrum.HKLDict","text":"HKLDict{D,T}\n\nAn alternative to HKLData uses a dictionary instead of an array as a backing field.\n\nThis is a more space-efficient alternative to HKLData in the case of reciprocal space data with a large number of zero components. For wavefunction data, which is often specified to some energy cutoff that corresponds to a distance in reciprocal space, there are many zero valued elements to the array. Unspecified elements in an HKLDict are assumed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.ReciprocalWavefunction","page":"Crystal data","title":"Electrum.ReciprocalWavefunction","text":"ReciprocalWavefunction{D,T<:Real}\n\nContains a wavefunction stored by k-points and bands in a planewave basis. Used to store data in VASP WAVECAR files. Each k-point is expected to have the same number of bands.\n\nEvery band has associated data containing coefficients of the constituent planewaves stored in a HKLData{D,Complex{T}}. Unlike most data structures provided by this package, the type of complex number used does not default to Float64: wavefunction data is often supplied as a  Complex{Float32} since wavefunctions usually only converge to single precision, and Float64 storage would waste space.\n\nThe energies and occupancies are also stored in fields with the corresponding names, and can be accessed by spins, k-points, and bands, with indices in that order.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.nkpt","page":"Crystal data","title":"Electrum.nkpt","text":"nkpt(wf::ReciprocalWavefunction) -> Int\n\nReturns the number of k-points associated with a ReciprocalWavefunction.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.nband","page":"Crystal data","title":"Electrum.nband","text":"nband(b::BandAtKPoint) -> Int\n\nReturns the number of bands associated with a k-point.\n\n\n\n\n\nnband(wf::ReciprocalWavefunction) -> Int\n\nReturns the number of bands associated with a ReciprocalWavefunction. It is assumed that the number of bands is the same for each k-point and spin.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.ifft","page":"Crystal data","title":"AbstractFFTs.ifft","text":"ifft(g::HKLData) -> RealSpaceDataGrid\n\nPerforms an inverse fast Fourier transform on an HKLData and returns a RealSpaceDataGrid.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Density-of-states","page":"Crystal data","title":"Density of states","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.AbstractDensityOfStates\nElectrum.DensityOfStates\nElectrum.ProjectedDensityOfStates\nElectrum.nkpt\nElectrum.nband\nElectrum.bounds\nElectrum.fermi\nElectrum.smear\nElectrum.energies\nElectrum.nelectrons","category":"page"},{"location":"api/data.html#Electrum.AbstractDensityOfStates","page":"Crystal data","title":"Electrum.AbstractDensityOfStates","text":"AbstractDensityOfStates\n\nSupertype for all density of states data.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.DensityOfStates","page":"Crystal data","title":"Electrum.DensityOfStates","text":"DensityOfStates\n\nContains the total density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.ProjectedDensityOfStates","page":"Crystal data","title":"Electrum.ProjectedDensityOfStates","text":"ProjectedDensityOfStates\n\nContains projected density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.bounds","page":"Crystal data","title":"Electrum.bounds","text":"bounds(wf::ReciprocalWavefunction)\n\nGets the range of valid G-vectors in a ReciprocalWavefunction.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.fermi","page":"Crystal data","title":"Electrum.fermi","text":"fermi(wf::ReciprocalWavefunction) -> Float64\n\nEstimates the Fermi energy associated with a reciprocal space wavefunction using the energy and occupancy data in the ReciprocalWavefunction.\n\n\n\n\n\nfermi(d::AbstractDensityOfStates) -> Float64\n\nGets the Fermi energy from DOS data. There are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.smear","page":"Crystal data","title":"Electrum.smear","text":"smear(dos::DensityOfStates, sigma::Real)\n\nSmears the DOS function by convoluting it with a normalized Gaussian function with width sigma.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.energies","page":"Crystal data","title":"Electrum.energies","text":"energies(d::AbstractDensityOfStates; usefermi=false) -> Vector{Float64}\n\nGets the range of energies in the dataset. If usefermi is set to true, the energies returned will be adjusted such that the Fermi energy is set to zero.\n\nThere are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.nelectrons","page":"Crystal data","title":"Electrum.nelectrons","text":"nelectrons(d::DensityOfStates)\n\nGets the approximate number of electrons that are needed to reach the Fermi level.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Atomic-data","page":"Crystal data","title":"Atomic data","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.SphericalHarmonic","category":"page"},{"location":"api/data.html#Electrum.SphericalHarmonic","page":"Crystal data","title":"Electrum.SphericalHarmonic","text":"SphericalHarmonic{Lmax}\n\nReal spherical harmonic components up to Lmax. This can be used to describe atomic orbitals or projections of data onto atomic sites.\n\n\n\n\n\n","category":"type"},{"location":"filetypes.html#File-formats","page":"File formats","title":"File formats","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl supports a variety of different file formats from abinit, VASP, and LAMMPS.","category":"page"},{"location":"filetypes.html#ABINIT","page":"File formats","title":"ABINIT","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Outputs from abinit 7.10.5 and abinit 8.10.3 are supported. The headers from these versions contain the numbers 57 and 80 respectively. Fundamentally, these files are FORTRAN binary files written in sequential access mode with 4-byte record markers.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The file reading functionality from this package has not been tested on outputs from other versions of abinit, but may work for other releases in versions 7 and 8 of abinit. However, these functions will fail if the header does not contain either of those numbers in the header.","category":"page"},{"location":"filetypes.html#Densities-and-potentials","page":"File formats","title":"Densities and potentials","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Density outputs are suffixed with _DEN when written by abinit. Depending on the calculation type, there can be either 1, 2, or 4 components (depending on the value of nsppol). The first component is always the total density.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"There is also the kinetic energy density with suffix _KDEN which should use the same format as electron density files.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Potential outputs can have several different suffixes depending on the component of the potential chosen to be written:","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"_POT: Total potential.\n_VPSP: Local components of the pseudopotentials used.\n_VHA: Hartree potential.\n_VHXC: Sum of the Hartree and exchange-correlation potentials.\n_VXC: Exchange-correlation potential. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Both density and potential files follow the same format. The read_abinit_density() and  read_abinit_potential() functions can be used to load in density and potential files.","category":"page"},{"location":"filetypes.html#Wavefunctions","page":"File formats","title":"Wavefunctions","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Wavefunctions can be read in by read_abinit_wavefunction(). This assumes that the wavefunction is stored by k-points (istwfk should be equal to nkpt*1 in the input file).","category":"page"},{"location":"filetypes.html#VASP","page":"File formats","title":"VASP","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Unfortunately, VASP file formats generally do not map neatly onto the data structures provided by Electrum.jl.","category":"page"},{"location":"filetypes.html#Files-generated-by-VASP-calculations","page":"File formats","title":"Files generated by VASP calculations","text":"","category":"section"},{"location":"filetypes.html#DOSCAR","page":"File formats","title":"DOSCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The DOSCAR file contains data need to plot a density of states curve.","category":"page"},{"location":"filetypes.html#POSCAR-and-CONTCAR","page":"File formats","title":"POSCAR and CONTCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The POSCAR file contains the basis vectors and all of the atomic positions used to generate a crystal structure. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The CONTCAR file is where the atomic positions from a calculation are written. In the case of geometry optimizations, the contents of this file will differ.","category":"page"},{"location":"filetypes.html#PROCAR","page":"File formats","title":"PROCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The PROCAR file contains data needed to plot fat bands (band structures that contain information about contributions from atomic orbitals).","category":"page"},{"location":"filetypes.html#WAVECAR","page":"File formats","title":"WAVECAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The WAVECAR file contains the coefficients for the wavefunction's reciprocal space representation at each k-point. ","category":"page"},{"location":"filetypes.html#Functions","page":"File formats","title":"Functions","text":"","category":"section"},{"location":"filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/crystals.html#Crystals","page":"Crystals","title":"Crystals","text":"","category":"section"},{"location":"api/crystals.html#Constructors-and-types","page":"Crystals","title":"Constructors and types","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.AbstractCrystal\nElectrum.Crystal\nElectrum.CrystalWithDatasets","category":"page"},{"location":"api/crystals.html#Electrum.AbstractCrystal","page":"Crystals","title":"Electrum.AbstractCrystal","text":"AbstractCrystal{D}\n\nA crystal structure in D dimensions, containing information about the lattice, space group, and atoms contained within the crystal.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.Crystal","page":"Crystals","title":"Electrum.Crystal","text":"Crystal{D} <: AbstractCrystal{D}\n\nA crystal structure in D dimensions. Contains information about the lattice, space group, and atoms. This is a mutable data structure.\n\nAt minimum, a list of atomic positions (as an AtomList) is needed to generate a Crystal. Optionally, space group number and the origin of the space group may be provided.\n\nA transform may also be specified that converts the basis vectors of the AtomList to a favored representation, most often the conventional lattice. If it is not specified, it is filled with an identity matrix by default. The matrix is right-multiplied with the basis vectors to produce the favored representation. Because the rows of the transformation naturally correspond to the operations performed on each constituent basis vector, it may be easier to enter the transform as a transpose (or equivalently, an adjoint) when entered manually.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.CrystalWithDatasets","page":"Crystals","title":"Electrum.CrystalWithDatasets","text":"CrystalWithDatasets{D,K,V} <: AbstractCrystal{D}\n\nA pairing of a Crystal{D} and a Dict{K,V} which allows for access to associated datasets.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Methods","page":"Crystals","title":"Methods","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.generators\nElectrum.set_transform!","category":"page"},{"location":"api/crystals.html#Electrum.generators","page":"Crystals","title":"Electrum.generators","text":"generators(xtal::AbstractCrystal{D}) -> PeriodicAtomList{D}\n\nReturns the list of generating atomic positions associated with a Crystal or CrystalWithDatasets.\n\nNote that this does not convert the input to a PeriodicAtomList with all atomic positions; only the minimal set that's needed to generate the atoms given the space group symmetry. To enumerate all of the atoms, use convert(PeriodicAtomList, xtal) or PeriodicAtomList(xtal).\n\n\n\n\n\n","category":"function"},{"location":"api/crystals.html#Electrum.set_transform!","page":"Crystals","title":"Electrum.set_transform!","text":"set_transform!(xtal::AbstractCrystal, M) -> AbstractCrystal\n\nSets the transform supplied with an AbstractCrystal. The transform can be an integer matrix, vector, scalar, or UniformScaling, which is converted to an SMatrix{D,D,Int} when stored.\n\nThe function returns the modified input for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"api/lattices.html#Constructors-and-types","page":"Lattices","title":"Constructors and types","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.AbstractBasis\nElectrum.RealBasis\nElectrum.ReciprocalBasis","category":"page"},{"location":"api/lattices.html#Electrum.AbstractBasis","page":"Lattices","title":"Electrum.AbstractBasis","text":"AbstractBasis{D}\n\nSupertype for sets of basis vectors in D dimensions.\n\nThis supertype includes the RealBasis{D} and ReciprocalBasis{D} types, which explicitly  indicate their units (assumed to be either angstroms or inverse angstroms).\n\nMembers of AbstractBasis must implement the following checks:\n\nThat the basis vectors are linearly independent and form a right-handed coordinate system, \n\nunless an explicit zero basis is constructed (implying no periodicity).\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.RealBasis","page":"Lattices","title":"Electrum.RealBasis","text":"RealBasis{D} <: AbstractBasis{D}\n\nA set of real space basis vectors, assumed to be in angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.ReciprocalBasis","page":"Lattices","title":"Electrum.ReciprocalBasis","text":"ReciprocalBasis{D} <: AbstractBasis{D}\n\nA set of reciprocal space basis vectors, assumed to be in inverse angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Methods","page":"Lattices","title":"Methods","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.lengths(::AbstractBasis)\nElectrum.volume(::AbstractBasis)\nElectrum.angles_cos\nElectrum.angles_rad\nElectrum.angles_deg\nElectrum.maxHKLindex","category":"page"},{"location":"api/lattices.html#Electrum.lengths-Tuple{AbstractBasis}","page":"Lattices","title":"Electrum.lengths","text":"lengths(b::AbstractBasis) -> Vector{Float64}\n\nReturns the lengths of the basis vectors.\n\n\n\n\n\nlengths(x) -> Float64\n\nCalculate the lengths of the basis vectors associated with x. These will be real space lengths (assumed to be in angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.volume-Tuple{AbstractBasis}","page":"Lattices","title":"Electrum.volume","text":"volume(b::AbstractBasis) -> Float64\n\nReturns the volume of a unit cell defined by a matrix. This volume does not carry the sign (negative for cells that do not follow the right hand rule).\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.angles_cos","page":"Lattices","title":"Electrum.angles_cos","text":"angles_cos(b::AbstractBasis) -> Vector{Float64}\n\nGenerates the cosines of the unit cell angles.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_rad","page":"Lattices","title":"Electrum.angles_rad","text":"angles_rad(b) -> Vector{Float64}\n\nReturns the angles (in radians) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_deg","page":"Lattices","title":"Electrum.angles_deg","text":"angles_deg(b) -> Vector{Float64}\n\nReturns the angles (in degrees) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Electrum.jl","page":"Home","title":"Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package that provides structs and methods for working with crystal structures.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is a package designed to make the development of chemical theory tools easier. Not only does it offer a type system that handles data commonly used in theory (such as real and reciprocal space data grids), it also offers broad support for filetypes common to chemical theory.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the future, we aim to support native Julia plotting of data processed by this package with a  separate package.","category":"page"},{"location":"index.html#Getting-Electrum.jl","page":"Home","title":"Getting Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As of this release, Electrum.jl is not in the Julia package registry. You'll need to manually add this repo to your Julia environment (which should be at least v1.6):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8 pkg)> add https://github.com/brainandforce/Electrum.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also do this by importing Pkg and entering the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\")","category":"page"},{"location":"index.html#Tracking-different-branches","page":"Home","title":"Tracking different branches","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you'd like to work on developing Electrum.jl, you probably want to work on the project's current  state, and not the release version. You can do this by specifying the branch you want to track (let's assume it's dev):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8) pkg> add https://github.com/brainandforce/Electrum.jl#dev","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\", rev=\"dev\")","category":"page"},{"location":"index.html#Licensing-and-attribution","page":"Home","title":"Licensing and attribution","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is MIT licensed. In short, this means that you can use this package however you like, without restrictions on relicensing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You are not required to cite this package if you use it in research, however, attribution is always appreciated. This is facilitated by the CITATION.cff file included in the repository.","category":"page"},{"location":"api/atoms.html#Atoms","page":"Atoms","title":"Atoms","text":"","category":"section"},{"location":"api/atoms.html#Constructors-and-types","page":"Atoms","title":"Constructors and types","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.NamedAtom\nElectrum.AbstractAtomPosition\nElectrum.CartesianAtomPosition\nElectrum.FractionalAtomPosition\nElectrum.AbstractAtomList\nElectrum.AtomList\nElectrum.PeriodicAtomList","category":"page"},{"location":"api/atoms.html#Electrum.NamedAtom","page":"Atoms","title":"Electrum.NamedAtom","text":"NamedAtom\n\nStores information about an atom, which includes a name which may be up to 8 codepoints long, and the atomic number.\n\nInternally, the name is stored as a NTuple{8,Char} in the name field to guarantee that the type is pure bits. However, the name property returns a String.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomPosition","page":"Atoms","title":"Electrum.AbstractAtomPosition","text":"AbstractAtomPosition{D}\n\nSupertype that describes atomic positions in D dimensions, which include name, coordinate, and occupancy information.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.CartesianAtomPosition","page":"Atoms","title":"Electrum.CartesianAtomPosition","text":"CartesianAtomPosition{D}\n\nDescribes an absolute atomic position. The coordinate in the pos field is assumed to be given in angstroms.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.FractionalAtomPosition","page":"Atoms","title":"Electrum.FractionalAtomPosition","text":"FractionalAtomPosition{D}\n\nDescribes an atomic position within a crystal or other periodic structure. The coordinate in the pos field is assumed to be given relative to the basis vectors of the structure.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomList","page":"Atoms","title":"Electrum.AbstractAtomList","text":"AbstractAtomList{D}\n\nSupertype for lists of atomic positions in D dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AtomList","page":"Atoms","title":"Electrum.AtomList","text":"AtomList{D}\n\nContains a list of CartesianAtomPosition objects, corresponding to atoms in free space without boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.PeriodicAtomList","page":"Atoms","title":"Electrum.PeriodicAtomList","text":"PeriodicAtomList{D}\n\nContains a list of FractionalAtomPosition objects with an associated basis, corresponding to atoms in a system with periodicity.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Extracting-data","page":"Atoms","title":"Extracting data","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.name\nElectrum.atomic_number\nElectrum.atomtypes\nElectrum.natomtypes\nElectrum.atomcounts","category":"page"},{"location":"api/atoms.html#Electrum.atomtypes","page":"Atoms","title":"Electrum.atomtypes","text":"atomtypes(l::AbstractAtomList; dummy=false) -> Vector{NamedAtom}\n\nReturns all unique NamedAtom types found in an AbstractAtomList. This vector is sorted by atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nTo obtain a list of all unique atom names or atomic numbers, use name.(atomtypes(l)) or num.(atomtypes(l)).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.natomtypes","page":"Atoms","title":"Electrum.natomtypes","text":"natomtypes(l::AbstractAtomList; dummy=false) -> Int\n\nReturns the number of types of atoms in an AbstractAtomList.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.atomcounts","page":"Atoms","title":"Electrum.atomcounts","text":"atomcounts(l::AbstractAtomList; dummy=false, names=false) -> Vector{Pair{NamedAtom,Int}}\n\nReturns pairs of atoms and the number of atoms in the AtomList with that atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Moving-and-processing-atom-lists","page":"Atoms","title":"Moving and processing atom lists","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.deduplicate\nElectrum.move_into_cell\nElectrum.supercell","category":"page"},{"location":"api/atoms.html#Electrum.deduplicate","page":"Atoms","title":"Electrum.deduplicate","text":"deduplicate(l::AbstractVector{T<:AbstractAtomPosition}; atol=sqrt(eps(Float64))) -> Vector{T}\ndeduplicate(l::AbstractAtomList; atol=sqrt(eps(Float64))) -> <:AbstractAtomList\n\nRemoves atoms that are duplicates or close to being duplicates. In order to be considered duplicates, the atoms must have both the atomic number, and their coordinates must be approximately equal (to within a total distance of sqrt(eps(Float64))).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.move_into_cell","page":"Atoms","title":"Electrum.move_into_cell","text":"move_into_cell(l::AbstractVector{T<:FractionalAtomPosition}; atol=sqrt(eps(Float64)))\n    -> Vector{T}\nmove_into_cell(l::PeriodicAtomList; atol=sqrt(eps(Float64))) -> PeriodicAtomList\n\nMoves atoms that may exist outside of the bounds of a unit cell (meaning that their fractional coordinates are not between 0 and 1) into the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.supercell","page":"Atoms","title":"Electrum.supercell","text":"supercell(l::PeriodicAtomList, M) -> PeriodicAtomList\n\nCreates a new AtomList with the basis vectors of a supercell generated by transforming the basis  vectors of the space by M, which may be an integer matrix, an integer vector which is treated as a diagonal matrix, or a plain integer, which performs a uniform scaling. This function will also generate new atomic positions to fill the cell.\n\nThe function performs this transformation by calculating the Smith normal form of the transformation matrix. This matrix provides the integer scaling factors needed to stretch the supercell, and the left unimodular factor is then used to perform the final transformation.\n\n\n\n\n\n","category":"function"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electurm.jl provides a rich type system for handling a variety of data that may arise in  computational work with crystalline materials. Many of these types are generic enough to handle  cases of crystals in arbitrary dimension, which may be useful for theoretical work or for handling complicated real-world cases, such as incommensurately modulated crystals.","category":"page"},{"location":"types.html#Lattices-and-basis-vectors","page":"Types","title":"Lattices and basis vectors","text":"","category":"section"},{"location":"types.html#Basis-vectors","page":"Types","title":"Basis vectors","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis type contains two subtypes, RealBasis and ReciprocalBasis, which can be used to represent the basis vectors of a crystal.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractBasis types use the following conventions:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The units are assumed to be angstroms or inverse angstroms.\nConversion between the two involve a factor of 2π (multiplication for the RealBasis >  ","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"ReciprocalBasis conversion, and vice versa).","category":"page"},{"location":"types.html#Why-not-use-SMatrix-for-basis-vectors?","page":"Types","title":"Why not use SMatrix for basis vectors?","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"While the SMatrix type seems to make sense for a collection of basis vectors, it poses one major  problem: the calculation of type parameters.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The SMatrix{D1,D2,T,L} type requires four type parameters - D1 and D2 are each of the matrix dimensions, and T is the element type of the matrix. However, one last parameter is needed: L,  the length of the NTuple that backs the SMatrix.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a serious problem in the declaration of structs. Technically, a type like SMatrix{3,3,Float64} is an abstract type, as the L parameter is undeclared, even though the  value of L can be inferred from D1 and D2. By declaring a struct to have this type, there seems to be a significant performance drop.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis{D} types wrap an SVector{D,SVector{D,Float64}}. This only requires a single  type parameter D, and allows for fully concrete struct declarations. Various methods are defined on this type to make it work like a normal matrix, such as matrix multiplication.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The other issue is that there are contexts where real space basis vectors are easier to use and others where reciprocal basis vectors are easier to use. It's better to treat them as two interconvertible types for that reason.","category":"page"},{"location":"types.html#Real-and-reciprocal-lattices","page":"Types","title":"Real and reciprocal lattices","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electrum.jl provides real and reciprocal lattices as their own types: RealLattice and  ReciprocalLattice. Both of these are instances of AbstractLattice, and they may be freely converted between each other.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractLattice types consist of pairs of BasisVectors, a primitive set of basis vectors which may be accessed with prim() and a conventional set of basis vectors which may be accessed with conv().","category":"page"},{"location":"types.html#Crystals","page":"Types","title":"Crystals","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractCrystal supertype contains two concrete types, Crystal{D} and  CrystalWithDatasets{D,K,V}. The CrystalWithDatasets type is a combination of a Crystal{D} with a Dict{K,V}. ","category":"page"},{"location":"types.html#Crystal","page":"Types","title":"Crystal","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The Crystal data type consists of five pieces of information:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"A real space lattice (latt::RealLattice{D})\nThe space group number (sgno::Int)\nThe offset of the space group origin from the cell origin (orig::SVector{D,Float64})\nThe generating set of atomic positions (gen::AtomList{D})\nThe explicitly included set of atomic positions, or template (pos::AtomList{D})","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"There are two sets of atomic positions included: gen contains all of the atomic positions needed to describe the unit cell, and pos contains explicitly generated sites. The positions in pos  can be used to select sites to write to a file or display in a plot.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Currently, Electrum.jl does not deal with space group information, so the inclusion of a space group number or origin offset does not have any effect internally. In the future, we may be able to use this information to reduce the number of atomic positions stored in gen to the minimum generating set of atoms.","category":"page"},{"location":"types.html#CrystalWithDatasets","page":"Types","title":"CrystalWithDatasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"CrystalWithDatasets{D,K,V} is a struct that pairs a Crystal{D} with a Dict{K,V}. CrystalWithDatasets objects generated by Electrum.jl will almost always have K be a String.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"You can access datasets with getindex(), so a CrystalWithDatasets behaves similarly to a  dictionary. It should be noted that autocompletion is not currently supported for CrystalWithDatasets, and due to how Julia REPL functionality is implemented, adding this functionality may not be possible for the foreseeable future.","category":"page"},{"location":"types.html#Datasets","page":"Types","title":"Datasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electrum.jl supports a good number of different data types, including:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Real space datagrids\nReciprocal space data by HKL index\nBand structures and densities of states\nk-point lists and grids\nData by atomic position\nSpherical harmonic coefficients","category":"page"},{"location":"types.html#Real-space-datagrids","page":"Types","title":"Real space datagrids","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Real space data is usually represented with a RealSpaceDatagrid{D,T}, which consists of the following:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The basis vectors that define the unit cell which is described by the data ","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"(latt::BasisVectors{D})","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The shift of the data grid off of the unit cell origin (orig::SVector{D,Float64})\nThe grid of data values (grid::Array{T,D})","category":"page"},{"location":"types.html#Mathematical-operations-on-RealSpaceDataGrid","page":"Types","title":"Mathematical operations on RealSpaceDataGrid","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Supported unary mathematical operations on a RealSpaceDataGrid are negation (-) and the fast  Fourier transform (FFTW.fft()).","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Binary operations, however, need checks to ensure that two grids are compatible with each other. \"Compatible\" means:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The datagrids are of the same spatial dimension.\nThe basis vectors of both grids are identical.\nThe shifts of both grids are identical.\nThe number of elements along each dimension are identical.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Failure to meet any of these criteria will result in an AssertionError being thrown. The internal function Electrum.grid_check() performs these checks and is called before binary operations are  performed.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"In the future, we may relax the third requirement by using interpolation, though a warning will be thrown if this is invoked.","category":"page"}]
}
