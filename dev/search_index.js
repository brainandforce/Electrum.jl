var documenterSearchIndex = {"docs":
[{"location":"api/filetypes.html#File-types","page":"File formats","title":"File types","text":"","category":"section"},{"location":"api/filetypes.html#Miscellaneous","page":"File formats","title":"Miscellaneous","text":"","category":"section"},{"location":"api/filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.readXYZ\nXtal.readXSF\nXtal.readCPcoeff\nXtal.readCPgeo\nXtal.readCPcell","category":"page"},{"location":"api/filetypes.html#Xtal.readXYZ","page":"File formats","title":"Xtal.readXYZ","text":"readXYZ(io::IO) -> Vector{AtomPosition{3}}\n\nReads an XYZ file into a Vector{AtomPosition{3}}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readXSF","page":"File formats","title":"Xtal.readXSF","text":"readXSF3D(\n    io::IO;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads in an XCrysDen XSF file from an input stream and returns a CrystalWithDatasets{3} with all datasets that have been included within the file.\n\nSpace group and origin information are not supplied in XSF files, but they can be supplied using  the spgrp and origin keyword arguments. Centering information can be provided using the ctr  argument, but is overridden by a space group assignment.\n\n\n\n\n\nreadXSF3D(\n    filename::AbstractString;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads an XSF file at path filename.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readCPcoeff","page":"File formats","title":"Xtal.readCPcoeff","text":"readCPcoeff(io::IO, Lmax::Val{L}) -> SphericalComponents{L}\n\nReads in the spherical harmonic projection coefficients from a CPpackage2 calculation.\n\nBy default, CPpackage2 gives the coefficients for spherical harmonics up to a maximum l value of 6.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readCPgeo","page":"File formats","title":"Xtal.readCPgeo","text":"readCPgeo(io::IO) -> Vector{AtomPosition{3}}\n\nReads the atomic positions used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readCPcell","page":"File formats","title":"Xtal.readCPcell","text":"readCPcell(io::IO) -> RealBasis{3}\n\nReads the basis vectors of the unit cell used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Reading-2","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.writeXYZ\nXtal.writeXSF","category":"page"},{"location":"api/filetypes.html#Xtal.writeXYZ","page":"File formats","title":"Xtal.writeXYZ","text":"writeXYZ(io::IO, data::AbstractVector{<:AtomPosition})\nwriteXYZ(io::IO, data::AtomList)\nwriteXYZ(io::IO, data::AbstractCrystal)\n\nWrite an XYZ file based on a set of atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.writeXSF","page":"File formats","title":"Xtal.writeXSF","text":"writeXSF(io, xtal::AtomList{D})\n\nWrites the crystal component of an XCrysDen XSF file.\n\n\n\n\n\nwriteXSF(io::IO, key, data::RealSpaceDataGrid{D,T}; periodic=true)\n\nWrites the crystal component of an XCrysDen XSF file. By default, automatic wrapping of the  datagrid occurs (values are repeated at the end of each dimension).\n\n\n\n\n\nwriteXSF(io::IO, xtaldata::CrystalWithDatasets{D,K,V})\n\nWrites a CrystalWithDatasets to an XCrysDen XSF file.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#ABINIT-files","page":"File formats","title":"ABINIT files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-3","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.read_abinit_density\nXtal.read_abinit_potential\nXtal.read_abinit_wavefunction","category":"page"},{"location":"api/filetypes.html#Xtal.read_abinit_density","page":"File formats","title":"Xtal.read_abinit_density","text":"read_abinit_density(filename::AbstractString)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,Float64}}\n\nReads a FORTRAN binary formatted abinit density file. By default, abinit density files will have the suffix DEN, but no assumptions are made about suffixes.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin densities.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.read_abinit_potential","page":"File formats","title":"Xtal.read_abinit_potential","text":"read_abinit_potential(filename::AbstractString)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,T}} where T<:Union{Float64,ComplexF64}\n\nReads a FORTRAN binary formatted abinit potential file. \n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.read_abinit_wavefunction","page":"File formats","title":"Xtal.read_abinit_wavefunction","text":"read_abinit_wavefunction(filename::AbstractString)\n    -> CrystalWithDatasets{3,String,ReciprocalWavefunction{3,Float64}}\n\nReads a FORTRAN binary formatted abinit potential file. \n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#VASP-files","page":"File formats","title":"VASP files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-4","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.readDOSCAR\nXtal.readKPOINTS\nXtal.readPOSCAR\nXtal.readPROCAR\nXtal.readWAVECAR","category":"page"},{"location":"api/filetypes.html#Xtal.readDOSCAR","page":"File formats","title":"Xtal.readDOSCAR","text":"readDOSCAR(io::IO) -> Tuple{DensityOfStates, Vector{ProjectedDensityOfStates}}\n\nReads a DOSCAR file from VASP and returns its data as a tuple containing the total and projected density of states (if present).\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readKPOINTS","page":"File formats","title":"Xtal.readKPOINTS","text":"readKPOINTS(io::IO) -> KPointGrid{3}\n\nReads a KPOINTS file to get the k-point mesh. So far only supports regular mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readPOSCAR","page":"File formats","title":"Xtal.readPOSCAR","text":"readPOSCAR(io::IO) -> Crystal{3}\nreadCONTCAR(io::IO) -> Crystal{3}\n\nReads a VASP POSCAR or CONTCAR file.\n\nA POSCAR contains the basis vectors of the system (potentially given with a scaling factor), the  positions of all atoms as either Cartesian or reduced coordinates, and potentially information  needed to perform an ab initio MD run.\n\nA CONTCAR file is written at the end of a VASP run and contains the atomic coordinates after the calculation completed. This is relevant for geometry optimizations.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readPROCAR","page":"File formats","title":"Xtal.readPROCAR","text":"readPROCAR(io::IO) -> FatBands{3}\n\nReads an lm-decomposed PROCAR file from VASP and returns its data as a FatBands struct.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Xtal.readWAVECAR","page":"File formats","title":"Xtal.readWAVECAR","text":"readWAVECAR(io::IO) -> ReciprocalWavefunction{3,Float32}\n\nReads a WAVECAR file output from a VASP 4.6 calcuation.\n\nInformation about VASP WAVECAR files and much of the code was pulled from the WaveTrans website  (originally written in FORTRAN): https://www.andrew.cmu.edu/user/feenstra/wavetrans/\n\nThis function is limited to WAVECAR files which have an RTAG value of 45200 (meaning the data is given as a Complex{Float32}) and have only a collinear magnetic field applied, like WaveTrans. It should also be noted that the weights of the k-points are not present in the WAVECAR file, and are set to 1 by default.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.writePOSCAR4","category":"page"},{"location":"api/filetypes.html#Xtal.writePOSCAR4","page":"File formats","title":"Xtal.writePOSCAR4","text":"writePOSCAR4(\n    io::IO,\n    list::AtomList;\n    comment = Written by Xtal.jl,\n    names = false\n)\nwritePOSCAR4(io::IO, xtal::AbstractCrystal; kwargs...)\nwritePOSCAR4(filename::AbstractString, data; kwargs...)\n\nWrites crystal data to a VASP 4.6 POSCAR output. Dummy atoms are not written.\n\nThe first line, normally used to describe the system, may be altered by passing a printable object to comment.\n\nBy default, atom names are not written (since this seems to break VASP 4.6) but this may be overridden by setting names to true.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"api/filetypes.html#Reading-5","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html#Writing-2","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Xtal.write_lammps_data","category":"page"},{"location":"api/filetypes.html#Xtal.write_lammps_data","page":"File formats","title":"Xtal.write_lammps_data","text":"write_lammps_data(\n    io::IO,\n    list::AtomList{D}\n    sc::AbstractVecOrMat{<:Integer} = ones(Int,D);\n    dummy::Bool = false\n)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for running a molecular dynamics simulation. If provided, sc can be used to generate a supercell\n\nThis function currently only works correctly for 3D systems.\n\n\n\n\n\nwrite_lammps_data(\n    io::IO,\n    xtal::AbstractCrystal{D};\n    sc = diagm(ones(Int, D))::AbstractVector{<:Integer};\n    dummy::Bool = false \n)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for running a molecular dynamics simulation.\n\nThis function currently only works for 3D systems.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Crystal-data","page":"Crystal data","title":"Crystal data","text":"","category":"section"},{"location":"api/data.html#Real-space","page":"Crystal data","title":"Real space","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Xtal.AbstractRealSpaceData\nXtal.RealSpaceDataGrid\nXtal.grid\nXtal.volume\nXtal.voxelsize\nXtal.integrate\nXtal.fft","category":"page"},{"location":"api/data.html#Xtal.AbstractRealSpaceData","page":"Crystal data","title":"Xtal.AbstractRealSpaceData","text":"AbstractRealSpaceData{D}\n\nSupertype for crystal data that is defined in real space. This includes atomic coordinates.\n\nAny basis that is stored with a subtype of this type will be a RealBasis, and calling basis() on that subtype will always return a RealBasis.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.RealSpaceDataGrid","page":"Crystal data","title":"Xtal.RealSpaceDataGrid","text":"RealSpaceDataGrid{D,T} <: AbstractRealSpaceData{D}\n\nA data grid defined in real space, containing data of type T.\n\nBy convention, indexing of RealSpaceDataGrid is zero-based. This convention is used so that datasets where the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.grid","page":"Crystal data","title":"Xtal.grid","text":"grid(g::RealSpaceDataGrid{D,T}) -> Array{T,D}\n\nGets the array that backs a RealSpaceDataGrid{D,T}, which is an Array{T,D}.\n\n\n\n\n\ngrid(hkl::HKLData{D,T}) -> Array{T,D}\n\nReturns the array that contains the reciprocal space data. Note that this causes information about the index offset to be lost!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Xtal.volume","page":"Crystal data","title":"Xtal.volume","text":"volume(b::AbstractBasis) -> Float64\n\nReturns the volume of a unit cell defined by a matrix. This volume does not carry the sign (negative for cells that do not follow the right hand rule).\n\n\n\n\n\nvolume(g::RealSpaceDataGrid) -> Float64\n\nGets the crystal volume associated with a RealSpaceDataGrid.\n\nBy default, units are assumed to be cubic angstroms.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Xtal.voxelsize","page":"Crystal data","title":"Xtal.voxelsize","text":"voxelsize(g::RealSpaceDataGrid) -> Float64\n\nGets the size of a single voxel of a RealSpaceDataGrid.\n\nBy default, units are assumed to be cubic angstroms.\n\n\n\n\n\nvoxelsize(g::HKLData)\n\nGets the size of a voxel asssociated with the RealSpaceDataGrid that would be generated by  performing an inverse Fourier transform on the HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Xtal.integrate","page":"Crystal data","title":"Xtal.integrate","text":"integrate(g::RealSpaceDataGrid{D,T}) -> T\n\nPerforms an integration across all voxels, returning a scalar value.\n\n\n\n\n\nintegrate(f::Function, g::RealSpaceDataGrid{D,T}) -> T\n\nApplies the function f pointwise to the elements of a datagrid, then integrates the grid across all voxels.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.fft","page":"Crystal data","title":"AbstractFFTs.fft","text":"fft(g::RealSpaceDataGrid) -> HKLData\n\nPerforms a fast Fourier transform on the data in a RealSpaceDataGrid and returns an HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Reciprocal-space","page":"Crystal data","title":"Reciprocal space","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Xtal.AbstractReciprocalSpaceData\nXtal.AbstractKPoints\nXtal.AbstractHKL\nXtal.KPointGrid\nXtal.KPointList\nXtal.BandAtKPoint\nXtal.BandStructure\nXtal.FatBands\nXtal.HKLData\nXtal.HKLDict\nXtal.ReciprocalWavefunction\nXtal.nkpt\nXtal.nband","category":"page"},{"location":"api/data.html#Xtal.AbstractReciprocalSpaceData","page":"Crystal data","title":"Xtal.AbstractReciprocalSpaceData","text":"AbstractReciprocalSpaceData{D}\n\nSupertype for crystal data that is defined in reciprocal space.\n\nAny basis that is stored with a subtype of this type will be a ReciprocalBasis, and calling basis() on that subtype will always return a ReciprocalBasis.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.AbstractKPoints","page":"Crystal data","title":"Xtal.AbstractKPoints","text":"AbstractKPoints{D}\n\nSupertype for sets of k-points.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.AbstractHKL","page":"Crystal data","title":"Xtal.AbstractHKL","text":"AbstractHKL{D}\n\nSupertype for crystal data stored by HKL index.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.KPointGrid","page":"Crystal data","title":"Xtal.KPointGrid","text":"KPointGrid{D} <: AbstractKPoints{D}\n\nContains a grid used to generate k-points during a calculation.\n\nThe grid itself is given as an SMatrix{D,D,Int}, and can be interpreted as a set of D vectors  given in terms of the primitive basis. These vectors can alternatively be used to construct a  supercell.\n\nThe shift of the k-point mesh off Γ is given as an SVector{D,Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.KPointList","page":"Crystal data","title":"Xtal.KPointList","text":"KPointList{D} <: AbstractKPoints{D}\n\nContains a list of k-points and their associated weights. This is useful when describing an ordered list of k-points that are not associated with a grid - for instance, the k-points used in band  structure calculations. In the future, it will be possible to convert a KPointGrid to a KPointList.\n\nThe weights of k-points are used to compensate for their placement on sites with point symmetry. If no weights are provided, they are all assumed to be equal. Any explicit input of k-points weights will be normalized such that their sum is 1, following the convention used by abinit.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.BandAtKPoint","page":"Crystal data","title":"Xtal.BandAtKPoint","text":"BandAtKPoint\n\nStores information about a band's energy and its occupancy at a specific k-point.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.BandStructure","page":"Crystal data","title":"Xtal.BandStructure","text":"BandStructure{D}\n\nStores information about an electronic band structure, including the list of k-points used to generate the data (as a KPointList{D})and the band information at every k-point (as a  Vector{BandAtKPoint}).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.FatBands","page":"Crystal data","title":"Xtal.FatBands","text":"FatBands{D} <: AbstractReciprocalSpaceData{D}\n\nStores information relevant to plotting fatbands.\n\nFatBands.bands: matrix of energies at each [kpt, band].\nFatBands.projband: array of lm-decomposed band structure. [orbital, ion, band, kpt].\nFatBands.cband: array of complex-valued contributions to band structure.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.HKLData","page":"Crystal data","title":"Xtal.HKLData","text":"HKLData{D,T} <: AbstractReciprocalSpaceData{D}\n\nStores information associated with specific sets of reciprocal lattice vectors. Data can be accessed and modified using regular indexing, where indices may be negative.\n\nInternally, the data is stored such that the zero frequency components are at the first indices along that dimension. \n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.HKLDict","page":"Crystal data","title":"Xtal.HKLDict","text":"HKLDict{D,T}\n\nAn alternative to HKLData uses a dictionary instead of an array as a backing field.\n\nThis is a more space-efficient alternative to HKLData in the case of reciprocal space data with a large number of zero components. For wavefunction data, which is often specified to some energy cutoff that corresponds to a distance in reciprocal space, there are many zero valued elements to the array. Unspecified elements in an HKLDict are assumed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.ReciprocalWavefunction","page":"Crystal data","title":"Xtal.ReciprocalWavefunction","text":"ReciprocalWavefunction{D,T<:Real} <: AbstractReciprocalSpaceData{D}\n\nContains a wavefunction stored by k-points and bands in a planewave basis. Used to store data in VASP WAVECAR files. Each k-point is expected to have the same number of bands.\n\nEvery band has associated data containing coefficients of the constituent planewaves stored in a  HKLData{D,Complex{T}}. Unlike most data structures provided by this package, the type of complex number used does not default to Float64: wavefunction data is often supplied as a  Complex{Float32} since wavefunctions usually only converge to single precision, and Float64 storage would waste space.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Xtal.nkpt","page":"Crystal data","title":"Xtal.nkpt","text":"nkpt(k::KPointList{D}) -> Int\n\nGets the number of k-points in a KPointList.\n\n\n\n\n\nnkpt(wf::ReciprocalWavefunction) -> Int\n\nReturns the number of k-points associated with a ReciprocalWavefunction.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Xtal.nband","page":"Crystal data","title":"Xtal.nband","text":"nband(b::BandAtKPoint) -> Int\n\nReturns the number of bands associated with a k-point.\n\n\n\n\n\nnband(wf::ReciprocalWavefunction) -> Int\n\nReturns the number of bands associated with a ReciprocalWavefunction. It is assumed that the  number of bands is the same for each k-point and spin.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Density-of-states","page":"Crystal data","title":"Density of states","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Xtal.AbstractDensityOfStates\nXtal.DensityOfStates\nXtal.ProjectedDensityOfStates\nXtal.nkpt\nXtal.nband\nXtal.bounds\nXtal.fermi\nXtal.smear\nXtal.energies\nXtal.nelectrons","category":"page"},{"location":"api/data.html#Atomic-data","page":"Crystal data","title":"Atomic data","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Xtal.AtomicData\nXtal.SphericalComponents","category":"page"},{"location":"api/data.html#Xtal.AtomicData","page":"Crystal data","title":"Xtal.AtomicData","text":"AtomicData{D,T}\n\nData associated with individual atoms in a structure.\n\nThis is a type alias for Dict{AtomPosition{D},T}. Keys are AtomPosition entries, and the values may be of any type.\n\n\n\n\n\n","category":"type"},{"location":"filetypes.html#File-formats","page":"File formats","title":"File formats","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Xtal.jl supports a variety of different file formats from abinit, VASP, and LAMMPS.","category":"page"},{"location":"filetypes.html#ABINIT","page":"File formats","title":"ABINIT","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Outputs from abinit 7.10.5 and abinit 8.10.3 are supported. The headers from these versions contain the numbers 57 and 80 respectively. Fundamentally, these files are FORTRAN binary files written in sequential access mode with 4-byte record markers.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The file reading functionality from this package has not been tested on outputs from other versions of abinit, but may work for other releases in versions 7 and 8 of abinit. However, these functions will fail if the header does not contain either of those numbers in the header.","category":"page"},{"location":"filetypes.html#Densities-and-potentials","page":"File formats","title":"Densities and potentials","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Density outputs are suffixed with _DEN when written by abinit. Depending on the calculation type, there can be either 1, 2, or 4 components (depending on the value of nsppol). The first component is always the total density.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"There is also the kinetic energy density with suffix _KDEN which should use the same format as electron density files.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Potential outputs can have several different suffixes depending on the component of the potential chosen to be written:","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"_POT: Total potential.\n_VPSP: Local components of the pseudopotentials used.\n_VHA: Hartree potential.\n_VHXC: Sum of the Hartree and exchange-correlation potentials.\n_VXC: Exchange-correlation potential. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Both density and potential files follow the same format. The read_abinit_density() and  read_abinit_potential() functions can be used to load in density and potential files.","category":"page"},{"location":"filetypes.html#Wavefunctions","page":"File formats","title":"Wavefunctions","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Wavefunctions can be read in by read_abinit_wavefunction(). This assumes that the wavefunction is stored by k-points (istwfk should be equal to nkpt*1 in the input file).","category":"page"},{"location":"filetypes.html#VASP","page":"File formats","title":"VASP","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Unfortunately, VASP file formats generally do not map neatly onto the data structures provided by Xtal.jl.","category":"page"},{"location":"filetypes.html#Files-generated-by-VASP-calculations","page":"File formats","title":"Files generated by VASP calculations","text":"","category":"section"},{"location":"filetypes.html#DOSCAR","page":"File formats","title":"DOSCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The DOSCAR file contains data need to plot a density of states curve.","category":"page"},{"location":"filetypes.html#POSCAR-and-CONTCAR","page":"File formats","title":"POSCAR and CONTCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The POSCAR file contains the basis vectors and all of the atomic positions used to generate a crystal structure. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The CONTCAR file is where the atomic positions from a calculation are written. In the case of geometry optimizations, the contents of this file will differ.","category":"page"},{"location":"filetypes.html#PROCAR","page":"File formats","title":"PROCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The PROCAR file contains data needed to plot fat bands (band structures that contain information about contributions from atomic orbitals).","category":"page"},{"location":"filetypes.html#WAVECAR","page":"File formats","title":"WAVECAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The WAVECAR file contains the coefficients for the wavefunction's reciprocal space representation at each k-point. ","category":"page"},{"location":"filetypes.html#Functions","page":"File formats","title":"Functions","text":"","category":"section"},{"location":"filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/crystals.html#Crystals","page":"Crystals","title":"Crystals","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Xtal.AbstractCrystal\nXtal.Crystal\nXtal.CrystalWithDatasets","category":"page"},{"location":"api/crystals.html#Xtal.AbstractCrystal","page":"Crystals","title":"Xtal.AbstractCrystal","text":"AbstractCrystal{D}\n\nA crystal structure in D dimensions, containing information about the lattice, space group, and atoms contained within the crystal.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Xtal.Crystal","page":"Crystals","title":"Xtal.Crystal","text":"Crystal{D} <: AbstractCrystal{D}\n\nA crystal structure in D dimensions. Contains information about the lattice, space group, and atoms. This is a mutable data structure.\n\nAt minimum, a list of atomic positions (as an AtomList) is needed to generate a Crystal. Optionally, space group number and the origin of the space group may be provided. If sgno is set to 0, it will be assumed that coordinates are given in Cartesian coordinates in angstroms. Otherwise, it will be assumed that coordinates are fractional, given in terms of the unit cell basis.\n\nA transform may also be specified that converts the basis vectors of the AtomList to a favored representation, most often the conventional lattice. If it is not specified, it is filled with an identity matrix by default. The matrix is right-multiplied with the basis vectors to produce the favored representation. Because the rows of the transformation naturally correspond to the operations performed on each constituent basis vector, it may be easier to enter the transform as a transpose (or equivalently, an adjoint) when entered manually.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Xtal.CrystalWithDatasets","page":"Crystals","title":"Xtal.CrystalWithDatasets","text":"CrystalWithDatasets{D,K,V} <: AbstractCrystal{D}\n\nA pairing of a Crystal{D} and a Dict{K,V} which allows for access to associated datasets.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"api/lattices.html#Constructors-and-types","page":"Lattices","title":"Constructors and types","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Xtal.AbstractBasis\nXtal.RealBasis\nXtal.ReciprocalBasis\nXtal.lattice2D\nXtal.lattice3D","category":"page"},{"location":"api/lattices.html#Xtal.AbstractBasis","page":"Lattices","title":"Xtal.AbstractBasis","text":"AbstractBasis{D}\n\nSupertype for sets of basis vectors in D dimensions.\n\nThis supertype includes the RealBasis{D} and ReciprocalBasis{D} types, which explicitly  indicate their units (assumed to be either angstroms or inverse angstroms).\n\nMembers of AbstractBasis must implement the following checks:\n\nThat the basis vectors are linearly independent and form a right-handed coordinate system, \n\nunless an explicit zero basis is constructed (implying no periodicity).\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Xtal.RealBasis","page":"Lattices","title":"Xtal.RealBasis","text":"RealBasis{D} <: AbstractBasis{D}\n\nA set of real space basis vectors, assumed to be in angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Xtal.ReciprocalBasis","page":"Lattices","title":"Xtal.ReciprocalBasis","text":"ReciprocalBasis{D} <: AbstractBasis{D}\n\nA set of reciprocal space basis vectors, assumed to be in inverse angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Xtal.lattice2D","page":"Lattices","title":"Xtal.lattice2D","text":"lattice2D(a::Real, b::Real, γ::Real) -> RealBasis{2}\n\nConstructs a set of basis vectors in an SMatrix that correspond to a unit cell in 2D with the same length and angle parameters (in degrees).\n\nBy default, the b-vector is oriented along y. This selection corresponds to the default orientation chosen by lattice3D().\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Xtal.lattice3D","page":"Lattices","title":"Xtal.lattice3D","text":"lattice3D(a::Real, b::Real, c::Real, α::Real, β::Real, γ::Real) -> RealBasis{3}\n\nConstructs a set of basis vectors in an SMatrix that correspond to a unit cell in 3D with the same length and angle parameters (in degrees).\n\nBy default, the b-vector is oriented along y, and the a-vector is chosen to be perpendicular to z, leaving the c-vector to freely vary. This selection allows for the most convenient orientation of symmetry operations.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Methods","page":"Lattices","title":"Methods","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Xtal.lengths\nXtal.volume\nXtal.angles_cos\nXtal.angles_rad\nXtal.angles_deg\nXtal.maxHKLindex","category":"page"},{"location":"api/lattices.html#Xtal.lengths","page":"Lattices","title":"Xtal.lengths","text":"lengths(b::AbstractBasis) -> Vector{Float64}\n\nReturns the lengths of the basis vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Xtal.angles_cos","page":"Lattices","title":"Xtal.angles_cos","text":"angles_cos(b::AbstractBasis) -> Vector{Float64}\n\nGenerates the cosines of the unit cell angles.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Xtal.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Xtal.angles_rad","page":"Lattices","title":"Xtal.angles_rad","text":"angles_rad(b) -> Vector{Float64}\n\nReturns the angles (in radians) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Xtal.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Xtal.angles_deg","page":"Lattices","title":"Xtal.angles_deg","text":"angles_deg(b) -> Vector{Float64}\n\nReturns the angles (in degrees) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Xtal.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Xtal.jl","page":"Home","title":"Xtal.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package that provides structs and methods for working with crystal structures.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Xtal.jl is a package designed to make the development of chemical theory tools easier. Not only  does it offer a type system that handles data commonly used in theory (such as real and reciprocal space data grids), it also offers broad support for filetypes common to chemical theory.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the future, we aim to support native Julia plotting of data processed by this package with a  separate package.","category":"page"},{"location":"index.html#Getting-Xtal.jl","page":"Home","title":"Getting Xtal.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As of this release, Xtal.jl is not in the Julia package registry. You'll need to manually add this repo to your Julia environment (which should be at least v1.6):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8 pkg)> add https://github.com/brainandforce/Xtal.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also do this by importing Pkg and entering the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url=\"https://github.com/brainandforce/Xtal.jl\")","category":"page"},{"location":"index.html#Tracking-different-branches","page":"Home","title":"Tracking different branches","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you'd like to work on developing Xtal.jl, you probably want to work on the project's current  state, and not the release version. You can do this by specifying the branch you want to track (let's assume it's dev):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8) pkg> add https://github.com/brainandforce/Xtal.jl#dev","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Pkg.add(url=\"https://github.com/brainandforce/Xtal.jl\", rev=\"dev\")","category":"page"},{"location":"index.html#Licensing-and-attribution","page":"Home","title":"Licensing and attribution","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Xtal.jl is MIT licensed. In short, this means that you can use this  package however you like, without restrictions on relicensing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You are not required to cite this package if you use it in research, however, attribution is always appreciated. This is facilitated by the CITATION.cff file included in the repository.","category":"page"},{"location":"api/atoms.html#Atoms","page":"Atoms","title":"Atoms","text":"","category":"section"},{"location":"api/atoms.html#Constructors-and-types","page":"Atoms","title":"Constructors and types","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Xtal.AtomPosition\nXtal.AtomList","category":"page"},{"location":"api/atoms.html#Xtal.AtomPosition","page":"Atoms","title":"Xtal.AtomPosition","text":"AtomPosition{D} <: AbstractRealSpaceData{D}\n\nContains information about an atom in a crystal, including atomic number, the name of an atom, and its position. Atomic names may be set arbitrarily, but will default to the atomic symbol if not provided explicitly.\n\nAn atomic number of 0 indicates a dummy atom - this does not represent a real atom, but a position  of note within the structure. If no name is given for a dummy atom, it will be given the empty  string.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Xtal.AtomList","page":"Atoms","title":"Xtal.AtomList","text":"AtomList{D} <: AbstractRealSpaceData{D}\n\nA list of atomic positions with an associated basis. Atomic coordinates are given in terms of the  specified basis. If the basis is a zero matrix, the coordinates are assumed to be given in  angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Methods","page":"Atoms","title":"Methods","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Xtal.atomname\nXtal.atomicno\nXtal.coord\nXtal.natom\nXtal.basis\nXtal.cartesian\nXtal.reduce_coords","category":"page"},{"location":"api/atoms.html#Xtal.atomname","page":"Atoms","title":"Xtal.atomname","text":"atomname(a::AtomPosition) -> String\n\nReturns the name of the atom. Note that this returns the name that was provided during construction, which is not guaranteed to be the same as the name of the element that has the given atomic number.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.atomicno","page":"Atoms","title":"Xtal.atomicno","text":"atomicno(a::AtomPosition) -> Int\n\nGets the atomic number of an atom in an atomic position.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.coord","page":"Atoms","title":"Xtal.coord","text":"coord(a::AtomPosition{D}) -> SVector{D,Float64}\n\nReturns the coordinate associated with an atomic position.\n\n\n\n\n\ncoord(g::RealSpaceDataGrid, ind...) -> SVector{D,Float64}\n\nReturns the Cartesian coordinate associated with a grid datum at a given index.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.natom","page":"Atoms","title":"Xtal.natom","text":"natom(l::AtomList) -> Int\n\nGets the number of atoms in an AtomList.\n\n\n\n\n\nnatom(xtal::Crystal) -> Int\n\nReturns the number of atoms in a crystal's unit cell.\n\nThis function is currently not aware of space groups or settings, so if the generating set does not contain all the atoms in the cell, it will return the wrong value.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.basis","page":"Atoms","title":"Xtal.basis","text":"basis(g::RealSpaceDataGrid{D,T}) -> RealBasis{D}\n\nGets the basis vectors of a RealSpaceDataGrid.\n\n\n\n\n\nbasis(hkl::HKLData)\n\nReturns the real-space basis associated with an HKLData object.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.cartesian","page":"Atoms","title":"Xtal.cartesian","text":"cartesian(l::AtomList{D}) -> AtomList{D}\n\nConverts an AtomList from reduced coordinates (relative to some crystal basis) to Cartesian coordinates in space.\n\n\n\n\n\ncartesian(b::AbstractMatrix{<:Real}, a::AtomPosition{D}) -> AtomPosition{D}\n\nConverts an AtomPosition defined in terms of basis b to a new AtomPosition defined in  Cartesian coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Xtal.reduce_coords","page":"Atoms","title":"Xtal.reduce_coords","text":"reduce_coords(basis::AbstractMatrix{<:Real}, a::AtomPosition; incell=false)\n\nConvert a coordinate from a Cartesian basis to the crystal basis. If incell is true, the position vector components will be truncated so they lie within the cell bounds (between 0 and 1).\n\n\n\n\n\nreduce_coords(basis::AbstractMatrix{<:Real}, a::AbstractVector{AtomPosition}; incell=false)\n\nConvert a vector of atomic coordinates from a Cartesian basis to the crystal basis. If incell is true, the position vector components will be truncated so they lie within the cell bounds (between 0 and 1).\n\n\n\n\n\n","category":"function"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Xtal.jl provides a rich type system for handling a variety of data that may arise in computational work with crystalline materials. Many of these types are generic enough to handle cases of crystals in arbitrary dimension, which may be useful for theoretical work or for handling complicated  real-world cases, such as incommensurately modulated crystals.","category":"page"},{"location":"types.html#Lattices-and-basis-vectors","page":"Types","title":"Lattices and basis vectors","text":"","category":"section"},{"location":"types.html#Basis-vectors","page":"Types","title":"Basis vectors","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis type contains two subtypes, RealBasis and ReciprocalBasis, which can be used to represent the basis vectors of a crystal.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractBasis types use the following conventions:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The units are assumed to be angstroms or inverse angstroms.\nConversion between the two involve a factor of 2π (multiplication for the RealBasis >  ","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"ReciprocalBasis conversion, and vice versa).","category":"page"},{"location":"types.html#Why-not-use-SMatrix-for-basis-vectors?","page":"Types","title":"Why not use SMatrix for basis vectors?","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"While the SMatrix type seems to make sense for a collection of basis vectors, it poses one major  problem: the calculation of type parameters.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The SMatrix{D1,D2,T,L} type requires four type parameters - D1 and D2 are each of the matrix dimensions, and T is the element type of the matrix. However, one last parameter is needed: L,  the length of the NTuple that backs the SMatrix.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a serious problem in the declaration of structs. Technically, a type like SMatrix{3,3,Float64} is an abstract type, as the L parameter is undeclared, even though the  value of L can be inferred from D1 and D2. By declaring a struct to have this type, there seems to be a significant performance drop.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis{D} types wrap an SVector{D,SVector{D,Float64}}. This only requires a single  type parameter D, and allows for fully concrete struct declarations. Various methods are defined on this type to make it work like a normal matrix, such as matrix multiplication.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The other issue is that there are contexts where real space basis vectors are easier to use and others where reciprocal basis vectors are easier to use. It's better to treat them as two interconvertible types for that reason.","category":"page"},{"location":"types.html#Real-and-reciprocal-lattices","page":"Types","title":"Real and reciprocal lattices","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Xtal.jl provides real and reciprocal lattices as their own types: RealLattice and  ReciprocalLattice. Both of these are instances of AbstractLattice, and they may be freely converted between each other.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractLattice types consist of pairs of BasisVectors, a primitive set of basis vectors which may be accessed with prim() and a conventional set of basis vectors which may be accessed with conv().","category":"page"},{"location":"types.html#Crystals","page":"Types","title":"Crystals","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractCrystal supertype contains two concrete types, Crystal{D} and  CrystalWithDatasets{D,K,V}. The CrystalWithDatasets type is a combination of a Crystal{D} with a Dict{K,V}. ","category":"page"},{"location":"types.html#Crystal","page":"Types","title":"Crystal","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The Crystal data type consists of five pieces of information:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"A real space lattice (latt::RealLattice{D})\nThe space group number (sgno::Int)\nThe offset of the space group origin from the cell origin (orig::SVector{D,Float64})\nThe generating set of atomic positions (gen::AtomList{D})\nThe explicitly included set of atomic positions, or template (pos::AtomList{D})","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"There are two sets of atomic positions included: gen contains all of the atomic positions needed to describe the unit cell, and pos contains explicitly generated sites. The positions in pos  can be used to select sites to write to a file or display in a plot.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Currently, Xtal.jl does not deal with space group information, so the inclusion of a space group number or origin offset does not have any effect internally. In the future, we may be able to use this information to reduce the number of atomic positions stored in gen to the minimum generating set.","category":"page"},{"location":"types.html#CrystalWithDatasets","page":"Types","title":"CrystalWithDatasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"CrystalWithDatasets{D,K,V} is a struct that pairs a Crystal{D} with a Dict{K,V}. CrystalWithDatasets objects generated by Xtal.jl will almost always have K be a String.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"You can access datasets with getindex(), so a CrystalWithDatasets behaves similarly to a  dictionary. It should be noted that autocompletion is not currently supported for CrystalWithDatasets, and due to how Julia REPL functionality is implemented, adding this functionality may not be possible for the foreseeable future.","category":"page"},{"location":"types.html#Datasets","page":"Types","title":"Datasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Xtal.jl supports a good number of different data types, including:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Real space datagrids\nReciprocal space data by HKL index\nBand structures and densities of states\nk-point lists and grids\nData by atomic position\nSpherical harmonic coefficients","category":"page"},{"location":"types.html#Real-space-datagrids","page":"Types","title":"Real space datagrids","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Real space data is usually represented with a RealSpaceDatagrid{D,T}, which consists of the following:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The basis vectors that define the unit cell which is described by the data ","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"(latt::BasisVectors{D})","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The shift of the data grid off of the unit cell origin (orig::SVector{D,Float64})\nThe grid of data values (grid::Array{T,D})","category":"page"},{"location":"types.html#Mathematical-operations-on-RealSpaceDataGrid","page":"Types","title":"Mathematical operations on RealSpaceDataGrid","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Supported unary mathematical operations on a RealSpaceDataGrid are negation (-) and the fast  Fourier transform (FFTW.fft()).","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Binary operations, however, need checks to ensure that two grids are compatible with each other. \"Compatible\" means:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The datagrids are of the same spatial dimension.\nThe basis vectors of both grids are identical.\nThe shifts of both grids are identical.\nThe number of elements along each dimension are identical.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Failure to meet any of these criteria will result in an AssertionError being thrown. The internal function Xtal.grid_check() performs these checks and is called before binary operations are  performed.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"In the future, we may relax the third requirement by using interpolation, though a warning will be thrown if this is invoked.","category":"page"}]
}
