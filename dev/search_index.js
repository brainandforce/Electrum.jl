var documenterSearchIndex = {"docs":
[{"location":"api/filetypes.html#File-types","page":"File formats","title":"File types","text":"","category":"section"},{"location":"api/filetypes.html#Miscellaneous","page":"File formats","title":"Miscellaneous","text":"","category":"section"},{"location":"api/filetypes.html#Reading","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readXYZ\nElectrum.readXSF\nElectrum.readCPcoeff\nElectrum.readCPgeo\nElectrum.readCPcell","category":"page"},{"location":"api/filetypes.html#Electrum.readXYZ","page":"File formats","title":"Electrum.readXYZ","text":"readXYZ(io::IO) -> AtomList{3}\n\nReads an XYZ file into an AtomList{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readXSF","page":"File formats","title":"Electrum.readXSF","text":"readXSF3D(\n    io::IO;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads in an XCrysDen XSF file from an input stream and returns a CrystalWithDatasets{3} with all datasets that have been included within the file.\n\nSpace group and origin information are not supplied in XSF files, but they can be supplied using the spgrp and origin keyword arguments. Centering information can be provided using the ctr  argument, but is overridden by a space group assignment.\n\n\n\n\n\nreadXSF3D(\n    file;\n    spgrp::Integer = 0,\n    origin::AbstractVector{<:Real} = [0, 0, 0]\n    ctr::Symbol = :P\n) -> CrystalWithDatasets{3}\n\nReads an XSF file at path filename.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcoeff","page":"File formats","title":"Electrum.readCPcoeff","text":"readCPcoeff(file, Lmax::Val{L}=Val{6}()) -> SphericalComponents{L}\n\nReads in the spherical harmonic projection coefficients from a CPpackage2 calculation.\n\nBy default, CPpackage2 gives the coefficients for spherical harmonics up to a maximum l value of 6.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPgeo","page":"File formats","title":"Electrum.readCPgeo","text":"readCPgeo(file) -> Vector{AtomPosition{3}}\n\nReads the atomic positions used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readCPcell","page":"File formats","title":"Electrum.readCPcell","text":"readCPcell(file) -> RealBasis{3}\n\nReads the basis vectors of the unit cell used for a CPpackage2 calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Reading-2","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writeXYZ\nElectrum.writeXSF","category":"page"},{"location":"api/filetypes.html#Electrum.writeXYZ","page":"File formats","title":"Electrum.writeXYZ","text":"writeXYZ(io::IO, data::AbstractVector{<:AbstractAtomPosition})\nwriteXYZ(io::IO, data::AbstractAtomList)\nwriteXYZ(io::IO, data::AbstractCrystal)\n\nWrite an XYZ file based on a set of atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.writeXSF","page":"File formats","title":"Electrum.writeXSF","text":"writeXSF(io, xtal::PeriodicAtomList{D})\n\nWrites the crystal component of an XCrysDen XSF file.\n\n\n\n\n\nwriteXSF(io::IO, key, data::RealSpaceDataGrid{D,T}; periodic=true)\n\nWrites the crystal component of an XCrysDen XSF file. By default, automatic wrapping of the datagrid occurs (values are repeated at the end of each dimension).\n\n\n\n\n\nwriteXSF(io::IO, xtaldata::CrystalWithDatasets{D,K,V})\n\nWrites a CrystalWithDatasets to an XCrysDen XSF file.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#ABINIT-files","page":"File formats","title":"ABINIT files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-3","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.read_abinit_density\nElectrum.read_abinit_potential\nElectrum.read_abinit_wavefunction","category":"page"},{"location":"api/filetypes.html#Electrum.read_abinit_density","page":"File formats","title":"Electrum.read_abinit_density","text":"read_abinit_density(file)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,Float64}}\n\nReads a FORTRAN binary formatted abinit density file. By default, abinit density files will have the suffix DEN, but no assumptions are made about suffixes.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin densities.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_potential","page":"File formats","title":"Electrum.read_abinit_potential","text":"read_abinit_potential(file)\n    -> CrystalWithDatasets{3,String,RealSpaceDataGrid{3,T}} where T<:Union{Float64,ComplexF64}\n\nReads a FORTRAN binary formatted abinit potential file.\n\nBy default, abinit potential files will end in POT for the external potential, VHA for the  Hartree potential, VXC for the exchange-correlation potential, and VHXC for the sum of both the Hartree and exchange-correlation potentials.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nThe number of datasets returned depends on the value of nsppol in the header, as calculations with explicit treatment of spin will return spin-dependent potentials.\n\nDepending on the value of cplex, the datagrid(s) returned may be real or complex-valued.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.read_abinit_wavefunction","page":"File formats","title":"Electrum.read_abinit_wavefunction","text":"read_abinit_wavefunction(file)\n    -> CrystalWithDatasets{3,String,PlanewaveWavefunction{3,Complex{Float64}}}\n\nReads a FORTRAN binary formatted abinit wavefunction file.\n\nBy default, abinit returns wavefunction data in Complex{Float64} entries, and this formatting is maintained in the return type.\n\nThe header is used to automatically determine the file format, so this should read in any abinit density output (provided a function exists to parse that header).\n\nBy default, the function is verbose, with output printed for every k-point parsed, due to the large size of the wavefunction files. If this behavior is undesirable, the quiet keyword argument may be set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#VASP-files","page":"File formats","title":"VASP files","text":"","category":"section"},{"location":"api/filetypes.html#Reading-4","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.readDOSCAR\nElectrum.readKPOINTS\nElectrum.readPOSCAR\nElectrum.readPROCAR\nElectrum.readWAVECAR","category":"page"},{"location":"api/filetypes.html#Electrum.readDOSCAR","page":"File formats","title":"Electrum.readDOSCAR","text":"readDOSCAR(file) -> Tuple{DensityOfStates, Vector{ProjectedDensityOfStates}}\n\nReads a DOSCAR file from VASP and returns its data as a tuple containing the total and projected density of states (if present).\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readKPOINTS","page":"File formats","title":"Electrum.readKPOINTS","text":"readKPOINTS(file) -> KPointGrid{3}\n\nReads a KPOINTS file to get the k-point mesh. Currently, it only supports grid-generated meshes.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPOSCAR","page":"File formats","title":"Electrum.readPOSCAR","text":"readPOSCAR(file) -> PeriodicAtomList{3}\nreadCONTCAR(file) -> PeriodicAtomList{3}\n\nReads a VASP POSCAR or CONTCAR file.\n\nA POSCAR contains the basis vectors of the system (potentially given with a scaling factor), the positions of all atoms as either Cartesian or reduced coordinates, and potentially information needed to perform an ab initio MD run.\n\nA CONTCAR file is written at the end of a VASP run and contains the atomic coordinates after the calculation completed. This is relevant for geometry optimizations.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readPROCAR","page":"File formats","title":"Electrum.readPROCAR","text":"readPROCAR(file) -> FatBands{3}\n\nReads an lm-decomposed PROCAR file from VASP and returns its data as a FatBands{3}.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Electrum.readWAVECAR","page":"File formats","title":"Electrum.readWAVECAR","text":"readWAVECAR(file) -> PlanewaveWavefunction{3,Complex{Float32}}\n\nReads a WAVECAR file output from a VASP 4.6 calcuation to a PlanewaveWavefunction.\n\nInformation about VASP WAVECAR files and much of the code was adapted from WaveTrans (originally written in FORTRAN): https://www.andrew.cmu.edu/user/feenstra/wavetrans/\n\nThis function is limited to WAVECAR files which have an RTAG value of 45200 (meaning the data is given as a Complex{Float32}) and have only a collinear magnetic field applied, like WaveTrans. It should also be noted that the weights of the k-points are not present in the WAVECAR file, and are set to 1 by default.\n\nBy default, the function is verbose, with output printed for every k-point parsed, due to the large size of the wavefunction files. If this behavior is undesirable, the quiet keyword argument may be set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.writePOSCAR4","category":"page"},{"location":"api/filetypes.html#Electrum.writePOSCAR4","page":"File formats","title":"Electrum.writePOSCAR4","text":"writePOSCAR4(file, data; kwargs...)\n\nWrites crystal data to a VASP 4.6 POSCAR output. The data can be a PeriodicAtomList or an AbstractCrystal.\n\nBy default, atom names are not written (since this seems to break VASP 4.6) but this may be overridden by setting names to true (which prevents VESTA from crashing). Dummy atoms are not are not written by default, but they may be written by setting dummy=true.\n\nThe first line, normally used to describe the system, may be altered by passing a printable object to comment.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"api/filetypes.html#Reading-5","page":"File formats","title":"Reading","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.read_lammps_data","category":"page"},{"location":"api/filetypes.html#Electrum.read_lammps_data","page":"File formats","title":"Electrum.read_lammps_data","text":"read_lammps_data(io::IO; atoms::AbstractVector = NamedAtom[]) -> PeriodicAtomList{3}\n\nReads a LAMMPS data file containing atomic coordinates. Currently, this function only supports 3D crystal data.\n\nIf set, the atom_types keyword can be used to define the types of atoms being read in. This can be and AbstractVector{NamedAtom}, AbstractVector{<:AbstractString}, or AbstractVector{<:Integer}. If it is not set or empty, then all atoms will be read in as dummy atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/filetypes.html#Writing-2","page":"File formats","title":"Writing","text":"","category":"section"},{"location":"api/filetypes.html","page":"File formats","title":"File formats","text":"Electrum.write_lammps_data","category":"page"},{"location":"api/filetypes.html#Electrum.write_lammps_data","page":"File formats","title":"Electrum.write_lammps_data","text":"write_lammps_data(io::IO, list::PeriodicAtomList, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for running a molecular dynamics simulation. \n\nIf transform is supplied, the list of atoms will be converted to a supercell with the associated transformation (either a matrix, vector, or scalar). The dummy keyword determines whether dummy atoms are included in the output (false by default).\n\nThis function currently only works for 3D systems.\n\n\n\n\n\nwrite_lammps_data(io::IO, xtal::AbstractCrystal, [transform]; dummy::Bool = false)\n\nWrites crystal information to a LAMMPS data format that can be used to define a simulation box for for running a molecular dynamics simulation. \n\nThe list of atoms that is written is given by converting xtal to a PeriodicAtomList, which uses the supplied transformation matrix to generate all atomic positions. If transform is supplied, the transformation will be applied to the PeriodicAtomList - it does not replace the transform provided with xtal.\n\nThis function currently only works for 3D systems.\n\n\n\n\n\nwrite_lammps_data(file, data, [transform]; dummy::Bool = false)\n\nWrites a LAMMPS data file to the path given by filename.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Crystal-data","page":"Crystal data","title":"Crystal data","text":"","category":"section"},{"location":"api/data.html#General","page":"Crystal data","title":"General","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.lengths(::Any)\nElectrum.volume(::Any)\nElectrum.basis(::Any)","category":"page"},{"location":"api/data.html#Electrum.lengths-Tuple{Any}","page":"Crystal data","title":"Electrum.lengths","text":"lengths(b::AbstractBasis) -> Vector{Float64}\n\nReturns the lengths of the basis vectors.\n\n\n\n\n\nlengths(x) -> Float64\n\nCalculate the lengths of the basis vectors associated with x. These will be real space lengths (assumed to be in angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.volume-Tuple{Any}","page":"Crystal data","title":"Electrum.volume","text":"volume(x) -> Float64\n\nCalculate the volume of the basis associated with x. This will be a real space volume (assumed to be in cubic angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.basis-Tuple{Any}","page":"Crystal data","title":"Electrum.basis","text":"basis(x) -> AbstractBasis\n\nReturns the basis associated with some data in x. By default, it's assumed to be accessible via the property :basis.\n\nThe return value might be a RealBasis or a ReciprocalBasis, depending on the space in which data is represented. Use RealBasis(g) or ReciprocalBasis(g) if a specific type is needed.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Basic-data-grids","page":"Crystal data","title":"Basic data grids","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.AbstractDataGrid\nElectrum.RealSpaceDataGrid\nElectrum.voxelsize\nElectrum.integrate\nElectrum.HKLData\nElectrum.HKLDict\nElectrum.fft\nElectrum.ifft","category":"page"},{"location":"api/data.html#Electrum.AbstractDataGrid","page":"Crystal data","title":"Electrum.AbstractDataGrid","text":"AbstractDataGrid{D,T}\n\nSupertype for crystal data associated with a grid of entries of type T in real or reciprocal space of dimension D.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.RealSpaceDataGrid","page":"Crystal data","title":"Electrum.RealSpaceDataGrid","text":"RealSpaceDataGrid{D,T} <: AbstractDataGrid{D,T}\n\nA data grid defined in real space, containing data of type T.\n\nBy convention, indexing of RealSpaceDataGrid is zero-based. This convention is used so that datasets where the first entry corresponds to data at the origin can be indexed with zeros. However, getindex() is implemented such that the dataset may be indexed by any integer, with modulo math used to convert to an index within the grid.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.voxelsize","page":"Crystal data","title":"Electrum.voxelsize","text":"voxelsize(g::RealSpaceDataGrid) -> Float64\n\nGets the size of a single voxel of a RealSpaceDataGrid.\n\nBy default, units are assumed to be cubic angstroms.\n\n\n\n\n\nvoxelsize(g::HKLData)\n\nGets the size of a voxel asssociated with the RealSpaceDataGrid that would be generated by  performing an inverse Fourier transform on the HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.integrate","page":"Crystal data","title":"Electrum.integrate","text":"integrate(g::RealSpaceDataGrid{D,T}) -> T\n\nPerforms an integration across all voxels, returning a scalar value.\n\n\n\n\n\nintegrate(f::Function, g::RealSpaceDataGrid{D,T}) -> T\n\nApplies the function f pointwise to the elements of a datagrid, then integrates the grid across all voxels.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.HKLData","page":"Crystal data","title":"Electrum.HKLData","text":"HKLData{D,T} <: AbstractDataGrid{D,T}\n\nStores information associated with a reciprocal space basis. Data can be accessed and modified by using the G-vectors as indices. Associated k-point data is also provided; if no k-point is supplied it is assumed to be the gamma point (zero(SVector{D,Float64}))\n\nInternally, the data is stored such that the zero frequency components are at the first indices along that dimension. The data at G-vector [0, 0, 0] is stored in the backing array's [1, 1, 1] index, and the rest of the indices correspond to reciprocal space points using the FFT convention.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.HKLDict","page":"Crystal data","title":"Electrum.HKLDict","text":"HKLDict{D,T}\n\nAn alternative to HKLData uses a dictionary instead of an array as a backing field.\n\nThis is a more space-efficient alternative to HKLData in the case of reciprocal space data with a large number of zero components. For wavefunction data, which is often specified to some energy cutoff that corresponds to a distance in reciprocal space, there are many zero valued elements to the array. Unspecified elements in an HKLDict are assumed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#AbstractFFTs.fft","page":"Crystal data","title":"AbstractFFTs.fft","text":"fft(g::RealSpaceDataGrid) -> HKLData\n\nPerforms a fast Fourier transform on the data in a RealSpaceDataGrid and returns an HKLData.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#AbstractFFTs.ifft","page":"Crystal data","title":"AbstractFFTs.ifft","text":"ifft(g::HKLData) -> RealSpaceDataGrid\n\nPerforms an inverse fast Fourier transform on an HKLData and returns a RealSpaceDataGrid.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#More-complex-data-grids","page":"Crystal data","title":"More complex data grids","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.PlanewaveWavefunction\nElectrum.PlanewaveIndex\nElectrum.nspin(::PlanewaveWavefunction)\nElectrum.nkpt(::PlanewaveWavefunction)\nElectrum.nband(::PlanewaveWavefunction)\nElectrum.fermi(::PlanewaveWavefunction)","category":"page"},{"location":"api/data.html#Electrum.PlanewaveWavefunction","page":"Crystal data","title":"Electrum.PlanewaveWavefunction","text":"PlanewaveWavefunction{D,T} <: AbstractDataGrid{D,T}\n\nStores the components of a wavefunction constructed from a planewave basis. Usually, the coefficient data type T will be a ComplexF32, as in DFT calculations, double precision convergence of the density will correspond to single-precision converegnce of the wavefunction.\n\nInternally, coefficients are stored in an Array{4,T}. Indexing is then manually implemented, with a D-dimensional CartesianIndex used for accessing each coefficient associated with a G-vector. PlanewaveWavefunction instances are mutable, with getindex() and setindex!() defined for them, but they are not resizable, and the backing array should not be resized.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.PlanewaveIndex","page":"Crystal data","title":"Electrum.PlanewaveIndex","text":"Electrum.PlanewaveIndex{D}\n\nA special indexing type used to index the components of wavefunctions in a planewave basis.\n\nIn many computational chemistry packages, the standard indexing of wavefunction components occurs in the following canonical order: spins, k-points, bands, then the h, k, and l indices of the G-vectors associated with the coefficients. However, in many cases, users will want to select a spin, k-point, or band before selecting a G-vector index.\n\nTo keep the syntax intuitive while maintaining performance (mostly by ensuring that all of the components of a wavefunction are stored compactly) this index type ensures that the iteration occurs in a natural order for users and in an efficient order for Julia.\n\nThis also ensures that G-vectors with negative indices are handled correctly: while the canonical G-vectors are those within some defined ranges of indices, out of bounds indices are reinterpreted automatically using modulo arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.fermi-Tuple{PlanewaveWavefunction}","page":"Crystal data","title":"Electrum.fermi","text":"fermi(wf::PlanewaveWavefunction) -> Float64\n\nEstimates the Fermi energy associated with a reciprocal space wavefunction using the energy and occupancy data in the PlanewaveWavefunction.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#k-points","page":"Crystal data","title":"k-points","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.KPoint\nElectrum.KPointMesh","category":"page"},{"location":"api/data.html#Electrum.KPoint","page":"Crystal data","title":"Electrum.KPoint","text":"KPoint{D} <: DenseVector{D,Float64}\n\nStores a k-point with an associated weight that corresponds to the number of symmetry-equivalent k-points, stored as an integer.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.KPointMesh","page":"Crystal data","title":"Electrum.KPointMesh","text":"KPointMesh{D} <: AbstractVector{KPoint{D}}\n\nContains a list of k-points associated with a matrix describing the mesh that was used to generate the points, and its shift off the Γ point (origin). If the mesh used to generate the points is unknown, it will be set to the zero matrix of dimension D.\n\nA KPointMesh can be indexed as if it were an ordinary Vector{KPoint{D}}.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Band-structures","page":"Crystal data","title":"Band structures","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.BandAtKPoint\nElectrum.BandStructure\nElectrum.nkpt(::BandStructure)\nElectrum.nband(::BandStructure)\nElectrum.nband(::BandAtKPoint)\nElectrum.FatBands","category":"page"},{"location":"api/data.html#Electrum.BandAtKPoint","page":"Crystal data","title":"Electrum.BandAtKPoint","text":"BandAtKPoint\n\nStores information about a band's energy and its occupancy at a specific k-point.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.BandStructure","page":"Crystal data","title":"Electrum.BandStructure","text":"BandStructure{D}\n\nStores information about an electronic band structure, including the list of k-points used to generate the data (as am AbstractVector{KPoint{D}})and the band information at every k-point (as a Vector{BandAtKPoint}).\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.nband-Tuple{BandAtKPoint}","page":"Crystal data","title":"Electrum.nband","text":"nband(b::BandAtKPoint) -> Int\n\nReturns the number of bands associated with a k-point.\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.FatBands","page":"Crystal data","title":"Electrum.FatBands","text":"FatBands{D}\n\nStores information relevant to plotting fatbands.\n\nFatBands.bands: matrix of energies at each [kpt, band].\nFatBands.projband: array of lm-decomposed band structure. [orbital, ion, band, kpt].\nFatBands.cband: array of complex-valued contributions to band structure.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Density-of-states","page":"Crystal data","title":"Density of states","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.AbstractDensityOfStates\nElectrum.DensityOfStates\nElectrum.ProjectedDensityOfStates\nElectrum.fermi(::AbstractDensityOfStates)\nElectrum.smear\nElectrum.energies\nElectrum.nelectrons","category":"page"},{"location":"api/data.html#Electrum.AbstractDensityOfStates","page":"Crystal data","title":"Electrum.AbstractDensityOfStates","text":"AbstractDensityOfStates\n\nSupertype for all density of states data.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.DensityOfStates","page":"Crystal data","title":"Electrum.DensityOfStates","text":"DensityOfStates\n\nContains the total density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.ProjectedDensityOfStates","page":"Crystal data","title":"Electrum.ProjectedDensityOfStates","text":"ProjectedDensityOfStates\n\nContains projected density of states information.\n\n\n\n\n\n","category":"type"},{"location":"api/data.html#Electrum.fermi-Tuple{AbstractDensityOfStates}","page":"Crystal data","title":"Electrum.fermi","text":"fermi(d::AbstractDensityOfStates) -> Float64\n\nGets the Fermi energy from DOS data. There are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"method"},{"location":"api/data.html#Electrum.smear","page":"Crystal data","title":"Electrum.smear","text":"smear(dos::DensityOfStates, sigma::Real)\n\nSmears the DOS function by convoluting it with a normalized Gaussian function with width sigma.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.energies","page":"Crystal data","title":"Electrum.energies","text":"energies(d::AbstractDensityOfStates; usefermi=false) -> Vector{Float64}\n\nGets the range of energies in the dataset. If usefermi is set to true, the energies returned will be adjusted such that the Fermi energy is set to zero.\n\nThere are no guarantees on the unit of energy used!\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Electrum.nelectrons","page":"Crystal data","title":"Electrum.nelectrons","text":"nelectrons(d::DensityOfStates)\n\nGets the approximate number of electrons that are needed to reach the Fermi level.\n\n\n\n\n\n","category":"function"},{"location":"api/data.html#Atomic-data","page":"Crystal data","title":"Atomic data","text":"","category":"section"},{"location":"api/data.html","page":"Crystal data","title":"Crystal data","text":"Electrum.SphericalHarmonic","category":"page"},{"location":"api/data.html#Electrum.SphericalHarmonic","page":"Crystal data","title":"Electrum.SphericalHarmonic","text":"SphericalHarmonic{Lmax}\n\nReal spherical harmonic components up to Lmax. This can be used to describe atomic orbitals or projections of data onto atomic sites.\n\n\n\n\n\n","category":"type"},{"location":"filetypes.html#File-formats","page":"File formats","title":"File formats","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl supports a variety of different file formats from abinit, VASP, and LAMMPS.","category":"page"},{"location":"filetypes.html#ABINIT","page":"File formats","title":"ABINIT","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Outputs from abinit 7.10.5 and abinit 8.10.3 are supported and have been tested. The headers from these versions contain the numbers 57 and 80 respectively. Fundamentally, these files are FORTRAN binary files written in sequential access mode with 4-byte record markers.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The file reading functionality from this package has not been tested on outputs from other versions of abinit, but may work for the outputs of other abinit versions. However, these functions will fail if the header does not contain either of those numbers in the header.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"If other header formats are known to work, please file an issue to extend support for abinit outputs to that format.","category":"page"},{"location":"filetypes.html#Densities-and-potentials","page":"File formats","title":"Densities and potentials","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Density outputs are suffixed with _DEN when written by abinit. Depending on the calculation type, there can be either 1, 2, or 4 components (depending on the value of nsppol). The first component is always the total density.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"There is also the kinetic energy density with suffix _KDEN which should use the same format as electron density files.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Potential outputs can have several different suffixes depending on the component of the potential chosen to be written:","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"_POT: Total potential.\n_VPSP: Local components of the pseudopotentials used.\n_VHA: Hartree potential.\n_VHXC: Sum of the Hartree and exchange-correlation potentials.\n_VXC: Exchange-correlation potential. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Both density and potential files follow the same format. The read_abinit_density() and  read_abinit_potential() functions can be used to load in density and potential files.","category":"page"},{"location":"filetypes.html#Wavefunctions","page":"File formats","title":"Wavefunctions","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Wavefunctions can be read in by read_abinit_wavefunction(). This assumes that the wavefunction is stored by k-points (istwfk should be equal to nkpt*1 in the input file).","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Because wavefunctions are large files, and reading them can be slow, read_abinit_wavefunction() will print @info messages for every k-point that is read in. This can be disabled by setting the keyword argument quiet = true.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"!!! info abinit 7.10.5 (header version 57) does not output the matrix associated with the k-point mesh used in the calculation (the kptrlatt field).","category":"page"},{"location":"filetypes.html#VASP","page":"File formats","title":"VASP","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"File reading and writing has been tested with VASP 4. While the functions listed here are not guaranteed to work for future VASP versions, many can still be expected to work.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"By default, all functions that read VASP outputs will are named read<FILENAME>(). If called without arguments, or with a directory argument, they will search the current working directory or the directory argument for a file with the name FILENAME, as VASP calculations will generate those particular filenames in a directory where a calculation was run.","category":"page"},{"location":"filetypes.html#Files-generated-by-VASP-calculations","page":"File formats","title":"Files generated by VASP calculations","text":"","category":"section"},{"location":"filetypes.html#DOSCAR","page":"File formats","title":"DOSCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The DOSCAR file contains data need to plot a density of states curve.","category":"page"},{"location":"filetypes.html#POSCAR-and-CONTCAR","page":"File formats","title":"POSCAR and CONTCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The POSCAR file contains the basis vectors and all of the atomic positions used to generate a crystal structure.  The CONTCAR file is where the atomic positions from a calculation are written, and its format is identical to that of the POSCAR file. In the case of geometry optimizations, the contents of CONTCAR will differ from those of POSCAR. readPOSCAR() and readCONTCAR() will read these files into a PeriodicAtomList{3}.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"!!! info POSCAR files supported by VASP 4 do not contain explicit atomic identity information. If those are read in without modification, dummy atoms with numeric labels will be used instead of the true atom names.","category":"page"},{"location":"filetypes.html#PROCAR","page":"File formats","title":"PROCAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The PROCAR file contains data needed to plot fat bands (band structures that contain information about contributions from atomic orbitals).","category":"page"},{"location":"filetypes.html#WAVECAR","page":"File formats","title":"WAVECAR","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"The WAVECAR file contains the coefficients for the wavefunction's reciprocal space representation at each k-point. The wavefunction is stored in an order with sparse, implied indexing. ","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"!!! warn VASP does not store the weights of k-points in the WAVECAR, nor does it store the matrix that generated the k-point mesh. Naïve summing of quantities associated with each k-point should be avoided.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Like read_abinit_wavefunction(), readWAVECAR() will print @info messages by default for each k-point read in. This can be disabled by setting the keyword argument quiet = true.","category":"page"},{"location":"filetypes.html#LAMMPS","page":"File formats","title":"LAMMPS","text":"","category":"section"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"Electrum.jl supports the reading and writing of LAMMPS atomic position data.","category":"page"},{"location":"filetypes.html","page":"File formats","title":"File formats","text":"!!! info Like VASP POSCAR files, LAMMPS data files do not contain explicit atomic information. If none is provided, dummy atoms corresponding to each atom type will be used.","category":"page"},{"location":"api/crystals.html#Crystals","page":"Crystals","title":"Crystals","text":"","category":"section"},{"location":"api/crystals.html#Constructors-and-types","page":"Crystals","title":"Constructors and types","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.AbstractCrystal\nElectrum.Crystal\nElectrum.CrystalWithDatasets","category":"page"},{"location":"api/crystals.html#Electrum.AbstractCrystal","page":"Crystals","title":"Electrum.AbstractCrystal","text":"AbstractCrystal{D}\n\nA crystal structure in D dimensions, containing information about the lattice, space group, and atoms contained within the crystal.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.Crystal","page":"Crystals","title":"Electrum.Crystal","text":"Crystal{D} <: AbstractCrystal{D}\n\nA crystal structure in D dimensions. Contains information about the lattice, space group, and atoms. This is a mutable data structure.\n\nAt minimum, a list of atomic positions (as an AtomList) is needed to generate a Crystal. Optionally, space group number and the origin of the space group may be provided.\n\nA transform may also be specified that converts the basis vectors of the AtomList to a favored representation, most often the conventional lattice. If it is not specified, it is filled with an identity matrix by default. The matrix is right-multiplied with the basis vectors to produce the favored representation. Because the rows of the transformation naturally correspond to the operations performed on each constituent basis vector, it may be easier to enter the transform as a transpose (or equivalently, an adjoint) when entered manually.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Electrum.CrystalWithDatasets","page":"Crystals","title":"Electrum.CrystalWithDatasets","text":"CrystalWithDatasets{D,K,V} <: AbstractCrystal{D}\n\nA pairing of a Crystal{D} and a Dict{K,V} which allows for access to associated datasets.\n\n\n\n\n\n","category":"type"},{"location":"api/crystals.html#Methods","page":"Crystals","title":"Methods","text":"","category":"section"},{"location":"api/crystals.html","page":"Crystals","title":"Crystals","text":"Electrum.generators\nElectrum.set_transform!","category":"page"},{"location":"api/crystals.html#Electrum.generators","page":"Crystals","title":"Electrum.generators","text":"generators(xtal::AbstractCrystal{D}) -> PeriodicAtomList{D}\n\nReturns the list of generating atomic positions associated with a Crystal or CrystalWithDatasets.\n\nNote that this does not convert the input to a PeriodicAtomList with all atomic positions; only the minimal set that's needed to generate the atoms given the space group symmetry. To enumerate all of the atoms, use convert(PeriodicAtomList, xtal) or PeriodicAtomList(xtal).\n\n\n\n\n\n","category":"function"},{"location":"api/crystals.html#Electrum.set_transform!","page":"Crystals","title":"Electrum.set_transform!","text":"set_transform!(xtal::AbstractCrystal, M) -> AbstractCrystal\n\nSets the transform supplied with an AbstractCrystal. The transform can be an integer matrix, vector, scalar, or UniformScaling, which is converted to an SMatrix{D,D,Int} when stored.\n\nThe function returns the modified input for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"api/lattices.html#Constructors-and-types","page":"Lattices","title":"Constructors and types","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.AbstractBasis\nElectrum.RealBasis\nElectrum.ReciprocalBasis","category":"page"},{"location":"api/lattices.html#Electrum.AbstractBasis","page":"Lattices","title":"Electrum.AbstractBasis","text":"AbstractBasis{D}\n\nSupertype for sets of basis vectors in D dimensions.\n\nThis supertype includes the RealBasis{D} and ReciprocalBasis{D} types, which explicitly  indicate their units (assumed to be either angstroms or inverse angstroms).\n\nMembers of AbstractBasis must implement the following checks:\n\nThat the basis vectors are linearly independent and form a right-handed coordinate system, \n\nunless an explicit zero basis is constructed (implying no periodicity).\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.RealBasis","page":"Lattices","title":"Electrum.RealBasis","text":"RealBasis{D} <: AbstractBasis{D}\n\nA set of real space basis vectors, assumed to be in angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Electrum.ReciprocalBasis","page":"Lattices","title":"Electrum.ReciprocalBasis","text":"ReciprocalBasis{D} <: AbstractBasis{D}\n\nA set of reciprocal space basis vectors, assumed to be in inverse angstroms.\n\n\n\n\n\n","category":"type"},{"location":"api/lattices.html#Methods","page":"Lattices","title":"Methods","text":"","category":"section"},{"location":"api/lattices.html","page":"Lattices","title":"Lattices","text":"Electrum.lengths(::AbstractBasis)\nElectrum.volume(::AbstractBasis)\nElectrum.angles_cos\nElectrum.angles_rad\nElectrum.angles_deg\nElectrum.maxHKLindex","category":"page"},{"location":"api/lattices.html#Electrum.lengths-Tuple{AbstractBasis}","page":"Lattices","title":"Electrum.lengths","text":"lengths(b::AbstractBasis) -> Vector{Float64}\n\nReturns the lengths of the basis vectors.\n\n\n\n\n\nlengths(x) -> Float64\n\nCalculate the lengths of the basis vectors associated with x. These will be real space lengths (assumed to be in angstroms) for real space data, and reciprocal space lengths for reciprocal space data.\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.volume-Tuple{AbstractBasis}","page":"Lattices","title":"Electrum.volume","text":"volume(b::AbstractBasis) -> Float64\n\nReturns the volume of a unit cell defined by a matrix. This volume does not carry the sign (negative for cells that do not follow the right hand rule).\n\n\n\n\n\n","category":"method"},{"location":"api/lattices.html#Electrum.angles_cos","page":"Lattices","title":"Electrum.angles_cos","text":"angles_cos(b::AbstractBasis) -> Vector{Float64}\n\nGenerates the cosines of the unit cell angles.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_rad","page":"Lattices","title":"Electrum.angles_rad","text":"angles_rad(b) -> Vector{Float64}\n\nReturns the angles (in radians) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"api/lattices.html#Electrum.angles_deg","page":"Lattices","title":"Electrum.angles_deg","text":"angles_deg(b) -> Vector{Float64}\n\nReturns the angles (in degrees) between each pair of basis vectors.\n\nThe angles are generated in the correct order [α, β, γ] for 3-dimensional cells. This is achieved by reversing the output of Electrum.generate_pairs(). For crystals with more spatial dimensions, this may lead to unexpected results.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Electrum.jl","page":"Home","title":"Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package that provides structs and methods for working with crystal structures.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is a package designed to make the development of chemical theory tools easier. Not only does it offer a type system that handles data commonly used in theory (such as real and reciprocal space data grids), it also offers broad support for file types common to chemical theory.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the future, we aim to support native Julia plotting of data processed by this package with a  separate package that provides bindings to commonly used plotting utilities.","category":"page"},{"location":"index.html#Getting-Electrum.jl","page":"Home","title":"Getting Electrum.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As of this release, Electrum.jl is not in the Julia package registry. You'll need to manually add this repo to your Julia environment (which should be at least v1.6, and ideally the current release version):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8 pkg)> add https://github.com/brainandforce/Electrum.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also do this by importing Pkg and entering the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\")","category":"page"},{"location":"index.html#Tracking-different-branches","page":"Home","title":"Tracking different branches","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you'd like to work on developing Electrum.jl, you probably want to work on the project's current  state, and not the release version. You can do this by specifying the branch you want to track (let's assume it's next):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(@v1.8) pkg> add https://github.com/brainandforce/Electrum.jl#next","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Pkg.add(url=\"https://github.com/brainandforce/Electrum.jl\", rev=\"next\")","category":"page"},{"location":"index.html#Licensing-and-attribution","page":"Home","title":"Licensing and attribution","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Electrum.jl is MIT licensed. In short, this means that you can use this package however you like, without restrictions on relicensing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You are not required to cite this package if you use it in research, however, attribution is always appreciated. This is facilitated by the CITATION.cff file included in the repository.","category":"page"},{"location":"api/atoms.html#Atoms","page":"Atoms","title":"Atoms","text":"","category":"section"},{"location":"api/atoms.html#Constructors-and-types","page":"Atoms","title":"Constructors and types","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.NamedAtom\nElectrum.AbstractAtomPosition\nElectrum.CartesianAtomPosition\nElectrum.FractionalAtomPosition\nElectrum.AbstractAtomList\nElectrum.AtomList\nElectrum.PeriodicAtomList","category":"page"},{"location":"api/atoms.html#Electrum.NamedAtom","page":"Atoms","title":"Electrum.NamedAtom","text":"NamedAtom\n\nStores information about an atom, which includes a name which may be up to 8 codepoints long, and the atomic number.\n\nInternally, the name is stored as a NTuple{8,Char} in the name field to guarantee that the type is pure bits. However, the name property returns a String.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomPosition","page":"Atoms","title":"Electrum.AbstractAtomPosition","text":"AbstractAtomPosition{D}\n\nSupertype that describes atomic positions in D dimensions, which include name, coordinate, and occupancy information.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.CartesianAtomPosition","page":"Atoms","title":"Electrum.CartesianAtomPosition","text":"CartesianAtomPosition{D}\n\nDescribes an absolute atomic position. The coordinate in the pos field is assumed to be given in angstroms.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.FractionalAtomPosition","page":"Atoms","title":"Electrum.FractionalAtomPosition","text":"FractionalAtomPosition{D}\n\nDescribes an atomic position within a crystal or other periodic structure. The coordinate in the pos field is assumed to be given relative to the basis vectors of the structure.\n\nOccupancy information is provided in the occ field. Note that no checking is done to ensure that the occupancy is a reasonable value.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AbstractAtomList","page":"Atoms","title":"Electrum.AbstractAtomList","text":"AbstractAtomList{D}\n\nSupertype for lists of atomic positions in D dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.AtomList","page":"Atoms","title":"Electrum.AtomList","text":"AtomList{D}\n\nContains a list of CartesianAtomPosition objects, corresponding to atoms in free space without boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Electrum.PeriodicAtomList","page":"Atoms","title":"Electrum.PeriodicAtomList","text":"PeriodicAtomList{D}\n\nContains a list of FractionalAtomPosition objects with an associated basis, corresponding to atoms in a system with periodicity.\n\n\n\n\n\n","category":"type"},{"location":"api/atoms.html#Extracting-data","page":"Atoms","title":"Extracting data","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.name\nElectrum.atomic_number\nElectrum.atomtypes\nElectrum.natomtypes\nElectrum.atomcounts","category":"page"},{"location":"api/atoms.html#Electrum.atomtypes","page":"Atoms","title":"Electrum.atomtypes","text":"atomtypes(l::AbstractAtomList; dummy=false) -> Vector{NamedAtom}\n\nReturns all unique NamedAtom types found in an AbstractAtomList. This vector is sorted by atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nTo obtain a list of all unique atom names or atomic numbers, use name.(atomtypes(l)) or num.(atomtypes(l)).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.natomtypes","page":"Atoms","title":"Electrum.natomtypes","text":"natomtypes(l::AbstractAtomList; dummy=false) -> Int\n\nReturns the number of types of atoms in an AbstractAtomList.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.atomcounts","page":"Atoms","title":"Electrum.atomcounts","text":"atomcounts(l::AbstractAtomList; dummy=false, names=false) -> Vector{Pair{NamedAtom,Int}}\n\nReturns pairs of atoms and the number of atoms in the AtomList with that atomic number.\n\nThe dummy keyword controls whether dummy atoms are counted as a separate atom type (false by default).\n\nThe use_names keyword determines whether the atoms counted separately based on atom names. By default, this is equal to dummy, so names are only factored in if dummy atoms are counted.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Moving-and-processing-atom-lists","page":"Atoms","title":"Moving and processing atom lists","text":"","category":"section"},{"location":"api/atoms.html","page":"Atoms","title":"Atoms","text":"Electrum.deduplicate\nElectrum.move_into_cell\nElectrum.supercell","category":"page"},{"location":"api/atoms.html#Electrum.deduplicate","page":"Atoms","title":"Electrum.deduplicate","text":"deduplicate(l::AbstractVector{T<:AbstractAtomPosition}; atol=sqrt(eps(Float64))) -> Vector{T}\ndeduplicate(l::AbstractAtomList; atol=sqrt(eps(Float64))) -> <:AbstractAtomList\n\nRemoves atoms that are duplicates or close to being duplicates. In order to be considered duplicates, the atoms must have both the atomic number, and their coordinates must be approximately equal (to within a total distance of sqrt(eps(Float64))).\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.move_into_cell","page":"Atoms","title":"Electrum.move_into_cell","text":"move_into_cell(l::AbstractVector{T<:FractionalAtomPosition}; atol=sqrt(eps(Float64)))\n    -> Vector{T}\nmove_into_cell(l::PeriodicAtomList; atol=sqrt(eps(Float64))) -> PeriodicAtomList\n\nMoves atoms that may exist outside of the bounds of a unit cell (meaning that their fractional coordinates are not between 0 and 1) into the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/atoms.html#Electrum.supercell","page":"Atoms","title":"Electrum.supercell","text":"supercell(l::PeriodicAtomList, M) -> PeriodicAtomList\n\nCreates a new AtomList with the basis vectors of a supercell generated by transforming the basis  vectors of the space by M, which may be an integer matrix, an integer vector which is treated as a diagonal matrix, or a plain integer, which performs a uniform scaling. This function will also generate new atomic positions to fill the cell.\n\nThe function performs this transformation by calculating the Smith normal form of the transformation matrix. This matrix provides the integer scaling factors needed to stretch the supercell, and the left unimodular factor is then used to perform the final transformation.\n\n\n\n\n\n","category":"function"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electrum.jl provides a rich type system for handling a variety of data that may arise in  computational work with periodic structures.. Many of these types are generic enough to handle cases of crystals in arbitrary dimension, which may be useful for theoretical work or for handling complicated real-world cases, such as incommensurately modulated crystals.","category":"page"},{"location":"types.html#Lattices-and-basis-vectors","page":"Types","title":"Lattices and basis vectors","text":"","category":"section"},{"location":"types.html#Basis-vectors","page":"Types","title":"Basis vectors","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis type contains two subtypes, RealBasis and ReciprocalBasis, which can be used to represent the basis vectors of a crystal.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractBasis types use the following conventions:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The units are assumed to be angstroms or inverse angstroms.\nConversion between the two involve a factor of 2π (multiplication for the RealBasis >  ","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"ReciprocalBasis conversion, and vice versa).","category":"page"},{"location":"types.html#Why-not-use-SMatrix-for-basis-vectors?","page":"Types","title":"Why not use SMatrix for basis vectors?","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"While the SMatrix type seems to make sense for a collection of basis vectors, it poses one major  problem: the calculation of type parameters.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The SMatrix{D1,D2,T,L} type requires four type parameters - D1 and D2 are each of the matrix dimensions, and T is the element type of the matrix. However, one last parameter is needed: L,  the length of the NTuple that backs the SMatrix.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a serious problem in the declaration of structs. Technically, a type like SMatrix{3,3,Float64} is an abstract type, as the L parameter is undeclared, even though the  value of L can be inferred from D1 and D2. By declaring a struct to have this type, there seems to be a significant performance drop.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractBasis{D} types wrap an SVector{D,SVector{D,Float64}}. This only requires a single  type parameter D, and allows for fully concrete struct declarations. Various methods are defined on this type to make it work like a normal matrix, such as matrix multiplication.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The other issue is that there are contexts where real space basis vectors are easier to use and others where reciprocal basis vectors are easier to use. It's better to treat them as two interconvertible types for that reason.","category":"page"},{"location":"types.html#Atoms","page":"Types","title":"Atoms","text":"","category":"section"},{"location":"types.html#NamedAtom","page":"Types","title":"NamedAtom","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The NamedAtom type stores two pieces of information - an atomic number and a name for the atom. Only the atomic number or an atomic symbol (given as an AbstractString) is required to name the atom, but both pieces of information can be provided.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Dummy atoms can be created by constructing a NamedAtom with a name that is not an atomic symbol or an atomic number of zero. These are useful for marking important positions in a unit cell.","category":"page"},{"location":"types.html#CartesianAtomPosition-and-FractionalAtomPosition","page":"Types","title":"CartesianAtomPosition and FractionalAtomPosition","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"These types are combinations of a NamedAtom and an SVector. A CartesianAtomPosition describes an atomic coordinate in the default length units (angstroms), and a FractionalAtomPosition describes an atomic coordinate with respect to a crystal lattice basis, which is not included with the coordinate.","category":"page"},{"location":"types.html#AtomList-and-PeriodicAtomList","page":"Types","title":"AtomList and PeriodicAtomList","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"These wrap Vector{CartesianAtomPosition{D}} and Vector{FractionalAtomPosition{D}}, respectively. A PeriodicAtomList describes atomic positions in a lattice, and thus includes a RealBasis{D}. ","category":"page"},{"location":"types.html#Crystals","page":"Types","title":"Crystals","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractCrystal supertype contains two concrete types, Crystal{D} and  CrystalWithDatasets{D,K,V}. The CrystalWithDatasets type is a combination of a Crystal{D} with a Dict{K,V}. ","category":"page"},{"location":"types.html#Crystal","page":"Types","title":"Crystal","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The Crystal data type consists of four pieces of information:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"A list of atoms with a basis (atoms::PeriodicAtomList{D})\nThe space group number (sgno::Int)\nThe offset of the space group origin from the cell origin (sgorig::SVector{D,Float64})\nAn integer linear transformation that describes a supercell (transform::SMatrix{D,D,Float64})","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Currently, Electrum.jl does not deal with space group information, so the inclusion of a space group number or origin offset does not have any effect internally. In the future, we may be able to use this information to reduce the number of atomic positions stored in atoms to the minimum needed to generate all atoms in the unit cell.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The linear transformation included with a Crystal is the identity matrix by default, but this can be changed using set_transform!(). This can be used with a crystal defined with a primitive lattice to lazily reference its conventional cell. ","category":"page"},{"location":"types.html#CrystalWithDatasets","page":"Types","title":"CrystalWithDatasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"CrystalWithDatasets{D,K,V} is a struct that pairs a Crystal{D} with a Dict{K,V}. CrystalWithDatasets objects generated by Electrum.jl will almost always have K be a String.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Datasets may be accessed with getindex(), so a CrystalWithDatasets behaves similarly to a  dictionary. It should be noted that autocompletion is not currently supported for CrystalWithDatasets, and due to how Julia REPL functionality is implemented, adding this functionality may not be possible for the foreseeable future.","category":"page"},{"location":"types.html#Datasets","page":"Types","title":"Datasets","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electrum.jl supports a good number of different data types, including:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Real space datagrids\nReciprocal space data by HKL index\nBand structures and densities of states\nk-point lists and grids\nData by atomic position\nSpherical harmonic coefficients","category":"page"},{"location":"types.html#Data-traits","page":"Types","title":"Data traits","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Electrum.jl uses a trait system to classify its types that are used to store non-structural crystal data. These are subtypes of Electrum.CrystalDataTrait and include Electrum.ByRealSpace() Electrum.ByReciprocalSpace(), and Electrum.ByAtom(), which correspond to data in real space, data in reciprocal space, and data associated with individual atomic positions, respectively.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"To recover the data space trait, data_space() may be called with either the object or object type. For custom types, this may be overloaded.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The RealBasis and ReciprocalBasis types return ByRealSpace() and ByReciprocalSpace(), respectively, and by default, any type with a field named :basis will return the data space trait associated with the type of that field.","category":"page"},{"location":"types.html#AbstractDataGrid-and-its-subtypes","page":"Types","title":"AbstractDataGrid and its subtypes","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"An AbstractDataGrid{D,T} contains data defined in a crystal lattice of D dimensions containing elements of type T, either in real space (RealSpaceDataGrid) or in reciprocal space (HKLData). At minimum, concrete subtypes must contain an AbstractBasis{D} and an Array{T,D} which contains the entries.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"AbstractDataGrid uses zero-based, periodic indexing: the first index of an AbstractDataGrid{D} is zero(NTuple{D,Int}), and indices whose moduli with respect to size along that dimension are identical will reference the same element: for instance, for g::AbstractDataGrid{3} with size (10, 10, 10), g[69, 420, 1337] === g[9, 0, 7]. Encountering a BoundsError is not possible when indexing an AbstractDataGrid.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The basis of an AbstractDataGrid can be recovered with basis(::AbstractDataGrid). If you decide to subtype AbstractDataGrid, note that the method is defined:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"basis(g::AbstractDataGrid) = g.basis","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The data type for the basis should be RealBasis if representing real space data and ReciprocalBasis if representing reciprocal space data, corresponding with the traits mentioned previously.","category":"page"},{"location":"types.html#Mathematical-operations","page":"Types","title":"Mathematical operations","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Supported unary mathematical operations on a RealSpaceDataGrid are negation (-) and the fast  Fourier transform (FFTW.fft()/FFTW.ifft()).","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Binary operations, however, need checks to ensure that two grids are compatible with each other. \"Compatible\" means:","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The datagrids are of the same spatial dimension.\nThe basis vectors of both grids are identical.\nThe shifts of both grids are identical.\nThe number of elements along each dimension are identical.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Failure to meet any of these criteria will result in an AssertionError being thrown. The internal function Electrum.grid_check() performs these checks and is called before binary operations are  performed. This function, in turn, calls Electrum.grid_specific_check() which can be overloaded by the user to perform other tests for custom subtypes of AbstractDataGrid. This function should return nothing and throw AssertionError when incompatible grids are found.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"In the future, we may relax some requirement by using Fourier interpolation, though a warning will be thrown if this is invoked.","category":"page"}]
}
