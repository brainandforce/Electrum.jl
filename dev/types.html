<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · Electrum.jl</title><meta name="title" content="Types · Electrum.jl"/><meta property="og:title" content="Types · Electrum.jl"/><meta property="twitter:title" content="Types · Electrum.jl"/><meta name="description" content="Documentation for Electrum.jl."/><meta property="og:description" content="Documentation for Electrum.jl."/><meta property="twitter:description" content="Documentation for Electrum.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Electrum.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="types.html">Types</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Lattices-and-basis-vectors"><span>Lattices and basis vectors</span></a></li><li><a class="tocitem" href="#Basis-vectors"><span>Basis vectors</span></a></li><li class="toplevel"><a class="tocitem" href="#Atoms"><span>Atoms</span></a></li><li><a class="tocitem" href="#NamedAtom"><span><code>NamedAtom</code></span></a></li><li><a class="tocitem" href="#CartesianAtomPosition-and-FractionalAtomPosition"><span><code>CartesianAtomPosition</code> and <code>FractionalAtomPosition</code></span></a></li><li><a class="tocitem" href="#AtomList-and-PeriodicAtomList"><span><code>AtomList</code> and <code>PeriodicAtomList</code></span></a></li><li><a class="tocitem" href="#Crystals"><span>Crystals</span></a></li><li class="toplevel"><a class="tocitem" href="#Datasets"><span>Datasets</span></a></li><li><a class="tocitem" href="#Data-traits"><span>Data traits</span></a></li><li><a class="tocitem" href="#DataGrid,-RealDataGrid,-and-ReciprocalDataGrid"><span><code>DataGrid</code>, <code>RealDataGrid</code>, and <code>ReciprocalDataGrid</code></span></a></li></ul></li><li><a class="tocitem" href="filetypes.html">File formats</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/lattices.html">Lattices</a></li><li><a class="tocitem" href="api/atoms.html">Atoms</a></li><li><a class="tocitem" href="api/crystals.html">Crystals</a></li><li><a class="tocitem" href="api/data.html">Crystal data</a></li><li><a class="tocitem" href="api/filetypes.html">File formats</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="types.html">Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="types.html">Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl/blob/main/docs/src/types.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><p>Electrum.jl provides a rich type system for handling a variety of data that may arise in  computational work with periodic structures. Many of these types are generic enough to handle cases of crystals in arbitrary dimension, which may be useful for theoretical work or for handling complicated real-world cases, such as incommensurately modulated crystals.</p><h1 id="Lattices-and-basis-vectors"><a class="docs-heading-anchor" href="#Lattices-and-basis-vectors">Lattices and basis vectors</a><a id="Lattices-and-basis-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices-and-basis-vectors" title="Permalink"></a></h1><h2 id="Basis-vectors"><a class="docs-heading-anchor" href="#Basis-vectors">Basis vectors</a><a id="Basis-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-vectors" title="Permalink"></a></h2><p>The <code>RealBasis</code> and <code>ReciprocalBasis</code>can be used to represent the basis vectors of a crystal. The types use the following conventions:</p><ul><li>The units are assumed to be bohr for lengths or rad bohr⁻¹ for inverse.</li><li>Conversion between the two involve a factor of 2π (multiplication for the <code>RealBasis</code> &gt;  </li></ul><p><code>ReciprocalBasis</code> conversion, and vice versa).</p><p>They are implemented by using the <code>Electrum.LatticeBasis{S,D,T}</code> type, where <code>S</code> is a the tag type <code>ByRealSpace</code> or <code>ByReciprocalSpace</code>, <code>D</code> is the dimension, and <code>T</code> is the element type.</p><h3 id="Why-not-use-SMatrix-for-basis-vectors?"><a class="docs-heading-anchor" href="#Why-not-use-SMatrix-for-basis-vectors?">Why not use <code>SMatrix</code> for basis vectors?</a><a id="Why-not-use-SMatrix-for-basis-vectors?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-not-use-SMatrix-for-basis-vectors?" title="Permalink"></a></h3><p>While the <code>SMatrix</code> type seems to make sense for a collection of basis vectors, it poses one major  problem: the calculation of type parameters.</p><p>The <code>SMatrix{D1,D2,T,L}</code> type requires four type parameters - <code>D1</code> and <code>D2</code> are each of the matrix dimensions, and <code>T</code> is the element type of the matrix. However, one last parameter is needed: <code>L</code>,  the length of the <code>NTuple</code> that backs the <code>SMatrix</code>.</p><p>Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a serious problem in the declaration of structs. Technically, a type like <code>SMatrix{3,3,Float64}</code> is an abstract type, as the <code>L</code> parameter is undeclared, even though the  value of <code>L</code> can be inferred from <code>D1</code> and <code>D2</code>. By declaring a struct to have this type, there seems to be a significant performance drop.</p><p>The <code>LatticeBasis</code> types wrap an <code>SVector{D,SVector{D,Float64}}</code>. This only requires a single  type parameter <code>D</code>, and allows for fully concrete struct declarations. Various methods are defined on this type to make it work like a normal matrix, such as matrix multiplication.</p><p>The other issue is that there are contexts where real space basis vectors are easier to use and others where reciprocal basis vectors are easier to use. It&#39;s better to treat them as two interconvertible types for that reason.</p><h1 id="Atoms"><a class="docs-heading-anchor" href="#Atoms">Atoms</a><a id="Atoms-1"></a><a class="docs-heading-anchor-permalink" href="#Atoms" title="Permalink"></a></h1><h2 id="NamedAtom"><a class="docs-heading-anchor" href="#NamedAtom"><code>NamedAtom</code></a><a id="NamedAtom-1"></a><a class="docs-heading-anchor-permalink" href="#NamedAtom" title="Permalink"></a></h2><p>The <code>NamedAtom</code> type stores two pieces of information - an atomic number and a name for the atom. Only the atomic number or an atomic symbol (given as an <code>AbstractString</code>) is required to name the atom, but both pieces of information can be provided.</p><p>Dummy atoms can be created by constructing a <code>NamedAtom</code> with a name that is not an atomic symbol or an atomic number of zero. These are useful for marking important positions in a unit cell.</p><h2 id="CartesianAtomPosition-and-FractionalAtomPosition"><a class="docs-heading-anchor" href="#CartesianAtomPosition-and-FractionalAtomPosition"><code>CartesianAtomPosition</code> and <code>FractionalAtomPosition</code></a><a id="CartesianAtomPosition-and-FractionalAtomPosition-1"></a><a class="docs-heading-anchor-permalink" href="#CartesianAtomPosition-and-FractionalAtomPosition" title="Permalink"></a></h2><p>These types are combinations of a <code>NamedAtom</code> and an <code>SVector</code>. A <code>CartesianAtomPosition</code> describes an atomic coordinate in the default length units (bohr), and a <code>FractionalAtomPosition</code> describes an atomic coordinate with respect to a crystal lattice basis, which is not included with the coordinate.</p><h2 id="AtomList-and-PeriodicAtomList"><a class="docs-heading-anchor" href="#AtomList-and-PeriodicAtomList"><code>AtomList</code> and <code>PeriodicAtomList</code></a><a id="AtomList-and-PeriodicAtomList-1"></a><a class="docs-heading-anchor-permalink" href="#AtomList-and-PeriodicAtomList" title="Permalink"></a></h2><p>These wrap <code>Vector{CartesianAtomPosition{D}}</code> and <code>Vector{FractionalAtomPosition{D}}</code>, respectively. A <code>PeriodicAtomList</code> describes atomic positions in a lattice, and thus includes a <code>RealBasis{D}</code>. </p><h2 id="Crystals"><a class="docs-heading-anchor" href="#Crystals">Crystals</a><a id="Crystals-1"></a><a class="docs-heading-anchor-permalink" href="#Crystals" title="Permalink"></a></h2><p>The <code>AbstractCrystal</code> supertype contains two concrete types, <code>Crystal{D}</code> and  <code>CrystalWithDatasets{D,K,V}</code>. The <code>CrystalWithDatasets</code> type is a combination of a <code>Crystal{D}</code> with a <code>Dict{K,V}</code>. </p><h3 id="Crystal"><a class="docs-heading-anchor" href="#Crystal"><code>Crystal</code></a><a id="Crystal-1"></a><a class="docs-heading-anchor-permalink" href="#Crystal" title="Permalink"></a></h3><p>The <code>Crystal</code> data type consists of four pieces of information:</p><ul><li>A list of atoms with a basis (<code>atoms::PeriodicAtomList{D}</code>)</li><li>The space group number (<code>sgno::Int</code>)</li><li>The offset of the space group origin from the cell origin (<code>sgorig::SVector{D,Float64}</code>)</li><li>An integer linear transformation that describes a supercell (<code>transform::SMatrix{D,D,Float64}</code>)</li></ul><p>Currently, Electrum.jl does not deal with space group information, so the inclusion of a space group number or origin offset does not have any effect internally. In the future, we may be able to use this information to reduce the number of atomic positions stored in <code>atoms</code> to the minimum needed to generate all atoms in the unit cell.</p><p>The linear transformation included with a <code>Crystal</code> is the identity matrix by default, but this can be changed using <code>set_transform!()</code>. This can be used with a crystal defined with a primitive lattice to lazily reference its conventional cell. </p><h3 id="CrystalWithDatasets"><a class="docs-heading-anchor" href="#CrystalWithDatasets"><code>CrystalWithDatasets</code></a><a id="CrystalWithDatasets-1"></a><a class="docs-heading-anchor-permalink" href="#CrystalWithDatasets" title="Permalink"></a></h3><p><code>CrystalWithDatasets{D,K,V}</code> is a struct that pairs a <code>Crystal{D}</code> with a <code>Dict{K,V}</code>. <code>CrystalWithDatasets</code> objects generated by Electrum.jl will almost always have <code>K</code> be a <code>String</code>.</p><p>Datasets may be accessed with <code>getindex()</code>, so a <code>CrystalWithDatasets</code> behaves similarly to a  dictionary. It should be noted that autocompletion is not currently supported for <code>CrystalWithDatasets</code>, and due to how Julia REPL functionality is implemented, adding this functionality may not be possible for the foreseeable future.</p><h1 id="Datasets"><a class="docs-heading-anchor" href="#Datasets">Datasets</a><a id="Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Datasets" title="Permalink"></a></h1><p>Electrum.jl supports a good number of different data types, including:</p><ul><li>Real space datagrids</li><li>Reciprocal space data by HKL index</li><li>Band structures and densities of states</li><li>k-point lists and grids</li><li>Data by atomic position</li><li>Spherical harmonic coefficients</li></ul><h2 id="Data-traits"><a class="docs-heading-anchor" href="#Data-traits">Data traits</a><a id="Data-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Data-traits" title="Permalink"></a></h2><p>Electrum.jl uses a trait system to classify its types that are used to store non-structural crystal data. These are subtypes of <code>Electrum.CrystalDataTrait</code> and include <code>Electrum.ByRealSpace{D}</code>, <code>Electrum.ByReciprocalSpace{D}</code>, and <code>Electrum.ByAtom</code>, which correspond to data in D-dimensional real space, data in D-dimensional reciprocal space, and data associated with individual atoms, respectively.</p><p>To recover the data space trait, <code>DataSpace()</code> may be called with either the object or object type. For custom types, this may be overloaded.</p><p>The <code>RealBasis{D}</code> and <code>ReciprocalBasis{D}</code> types return <code>ByRealSpace{D}()</code> and <code>ByReciprocalSpace{D}()</code>, respectively. By default, types that have a defined <code>basis()</code> function (or, by extension, a field <code>basis::Electrum.LatticeBasis</code>) will derive the trait from the return type of <code>basis()</code>.</p><h2 id="DataGrid,-RealDataGrid,-and-ReciprocalDataGrid"><a class="docs-heading-anchor" href="#DataGrid,-RealDataGrid,-and-ReciprocalDataGrid"><code>DataGrid</code>, <code>RealDataGrid</code>, and <code>ReciprocalDataGrid</code></a><a id="DataGrid,-RealDataGrid,-and-ReciprocalDataGrid-1"></a><a class="docs-heading-anchor-permalink" href="#DataGrid,-RealDataGrid,-and-ReciprocalDataGrid" title="Permalink"></a></h2><p>An <code>DataGrid{D,B&lt;:Electrum.LatticeBasis,S&lt;:AbstractVector{&lt;:Real},T}</code> contains data defined in a crystal lattice of <code>D</code> with basis vectors of type <code>B</code>, a shift parameter of type <code>S</code>, and elements of type <code>T</code>, either in real space (<code>RealDataGrid</code>) or in reciprocal space (<code>ReciprocalDataGrid</code>). These aliases are defined as follows:</p><pre><code class="language-julia hljs">const RealDataGrid{D,T} = DataGrid{D,RealBasis{D,Float64},SVector{D,Float64},T}
const ReciprocalDataGrid{D,T} = DataGrid{D,ReciprocalBasis{D,Float64},KPoint{D},T}</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Look closely at the above definition: the shift data type for <code>RealDataGrid{D}</code> is <code>SVector{D,Float64}</code>, but the shift data type for <code>ReciprocalDataGrid{D}</code> is <code>KPoint{D}</code>. When the <code>DataGrid</code> constructor without the shift type parameter is invoked, the basis type is used to infer the appropriate shift type so that a <code>RealDataGrid</code> or <code>ReciprocalDataGrid</code> is constructed.</p></div></div><p><code>DataGrid</code> uses zero-based, periodic indexing: the first index of an <code>AbstractDataGrid{D}</code> is <code>zero(NTuple{D,Int})</code>, and indices whose moduli with respect to size along that dimension are identical will reference the same element: for instance, for <code>g::AbstractDataGrid{3}</code> with size <code>(10, 10, 10)</code>, <code>g[69, 420, 1337] === g[9, 0, 7]</code>. Encountering a <code>BoundsError</code> is not possible when indexing an <code>DataGrid</code>.</p><p>The basis of an <code>DataGrid</code> can be recovered with <code>basis(::DataGrid)</code>, which will be of the type specified by the type parameter. </p><h3 id="Broadcasting-and-mathematical-operations"><a class="docs-heading-anchor" href="#Broadcasting-and-mathematical-operations">Broadcasting and mathematical operations</a><a id="Broadcasting-and-mathematical-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-and-mathematical-operations" title="Permalink"></a></h3><p>Broadcasting is defined for <code>DataGrid</code> with a custom <code>Base.Broadcast.BroadcastStyle</code> subtype:</p><pre><code class="language-julia hljs">Electrum.DataGridStyle{D,B,S} &lt;: Broadcast.AbstractArrayStyle{D}</code></pre><p>This allows <code>DataGrid</code> instances to operated on with dot syntax. However, they must share lattice basis vectors and shift values. If they do not match, an <code>Electrum.LatticeMismatch</code> exception will be thrown.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Although <code>Base.Broadcast.ArrayStyle</code> is usually overridden by other subtypes of  <code>Base.Broadcast.AbstractArrayStyle</code>, it does not override <code>Electrum.DataGridStyle</code>. Adding a <code>DataGrid</code> to an <code>Array</code> returns an <code>Array</code>, and adding a <code>DataGrid</code> to other <code>AbstractArray</code> subtypes returns the <code>AbstractArray</code> subtype defined by the <code>Broadcast.BroadcastStyle</code>. In the  case of a dimension mismatch, the broadcast style wll be <code>Broadcast.ArrayConflict</code> - the operation will throw a <code>DimensionMismatch</code>.</p></div></div><p>The <code>+</code> and <code>-</code> operators are defined for <code>DataGrid</code> instances, and they are faster than the broadcasted <code>.+</code> and <code>.-</code> equivalents. As with the broadcasted versions, checks are implemented to ensure that the lattice basis vectors and shifts match.</p><p>Similarly, the <code>*</code>, <code>/</code>, and <code>\</code> operators are defined for pairs of <code>DataGrid</code> and <code>Number</code> instances, and again, are faster than their broadcasted equivalents.</p><p>The Fourier transform and its inverse are available through an overload of <code>FFTW.fft()</code> and <code>FFTW.ifft()</code>. The transforms are normalized with respect to the basis vectors of the space, so for <code>g::DataGrid</code>, <code>ifft(fft(g)) ≈ g</code> (to within floating point error).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="filetypes.html">File formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Friday 20 October 2023 16:57">Friday 20 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
