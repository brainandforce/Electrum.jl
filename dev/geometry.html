<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geometry · Electrum.jl</title><meta name="title" content="Geometry · Electrum.jl"/><meta property="og:title" content="Geometry · Electrum.jl"/><meta property="twitter:title" content="Geometry · Electrum.jl"/><meta name="description" content="Documentation for Electrum.jl."/><meta property="og:description" content="Documentation for Electrum.jl."/><meta property="twitter:description" content="Documentation for Electrum.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Electrum.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="geometry.html">Geometry</a><ul class="internal"><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Coordinate-vectors"><span>Coordinate vectors</span></a></li><li><a class="tocitem" href="#Lattices"><span>Lattices</span></a></li><li><a class="tocitem" href="#Basis-vectors-in-composite-types"><span>Basis vectors in composite types</span></a></li></ul></li><li><a class="tocitem" href="atoms.html">Atoms and crystals</a></li><li><a class="tocitem" href="grids.html">Data grids</a></li><li><a class="tocitem" href="filetypes.html">File formats</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/traits.html">Traits</a></li><li><a class="tocitem" href="api/geometry.html">Geometry</a></li><li><a class="tocitem" href="api/atoms.html">Atoms</a></li><li><a class="tocitem" href="api/crystals.html">Crystals</a></li><li><a class="tocitem" href="api/data.html">Crystal data</a></li><li><a class="tocitem" href="api/filetypes.html">File formats</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="geometry.html">Geometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="geometry.html">Geometry</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl/blob/main/docs/src/geometry.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h1><p>The starting point for solid state structures is a periodic lattice. Electrum provides convenient types and functions for working with lattices of arbitrary dimension, not just three dimensions. </p><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><p>Julia parametric types can be used to encode information about data types that are wrapped by a new composite type: for instance, Julia&#39;s <code>Array{T,D}</code> type includes information about the types of the elements in the type parameter <code>T</code>. However, type parameters can be used as tags that provide additional information about data types without relying on inheritance from another abstract type. One example of this is <code>Ptr{T}</code>: although a pointer is underlyingly a <code>UInt</code>, the type parameter encodes the type of data pointed at.</p><p>Electrum uses several traits to encode information about numerical data, particularly vectors. If a user is given an instance of <code>SVector{3,Float64}</code>, the data type itself does not encode important information, like whether the data corresponds to a real or reciprocal space coordinate, or whether the coordinates are fractional coordinate or Cartesian coordinates. Electrum&#39;s data types use these traits in their declarations to convey this extra information.</p><h3 id="Conventions"><a class="docs-heading-anchor" href="#Conventions">Conventions</a><a id="Conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Conventions" title="Permalink"></a></h3><p>Trait types are declared as singleton structs (no fields). If more information needs to be encoded, use a type parameter. The names of traits generally tend to start with <code>By</code>.</p><p>If creating a new data type that uses one of the traits mentioned below, use the type itself as a parameter, not the singleton instance.</p><h3 id="Real-and-reciprocal-space"><a class="docs-heading-anchor" href="#Real-and-reciprocal-space">Real and reciprocal space</a><a id="Real-and-reciprocal-space-1"></a><a class="docs-heading-anchor-permalink" href="#Real-and-reciprocal-space" title="Permalink"></a></h3><p>The <code>BySpace</code> supertype contains two types, <code>ByRealSpace</code> and <code>ByReciprocalSpace</code>. These types are  used to denote whether data is associated with real space (e.g. electron density) or reciprocal  space (e.g. the Fourier transform of the electron density). When working with lattices, it is  important to distinguish the two types of lattice: this is the primary reason why bare <code>SMatrix{D,D,T}</code> instances are not used in this package.</p><p>The units associated with data bearing the <code>Electrum.ByRealSpace</code> trait are bohr or powers of bohr, whereas those associated with <code>Electrum.ByReciprocalSpace</code> are rad bohr⁻¹ or powers thereof.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.BySpace-geometry" href="#Electrum.BySpace-geometry"><code>Electrum.BySpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BySpace &lt;: Electrum.DataSpace</code></pre><p>Supertype for the <code>ByRealSpace</code> and <code>ByReciprocalSpace</code> traits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ByRealSpace-geometry" href="#Electrum.ByRealSpace-geometry"><code>Electrum.ByRealSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByRealSpace &lt;: BySpace</code></pre><p>Trait for real space data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ByReciprocalSpace-geometry" href="#Electrum.ByReciprocalSpace-geometry"><code>Electrum.ByReciprocalSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByReciprocalSpace &lt;: BySpace</code></pre><p>Trait for reciprocal space data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L44-L48">source</a></section></article><h3 id="Coordinate-system"><a class="docs-heading-anchor" href="#Coordinate-system">Coordinate system</a><a id="Coordinate-system-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-system" title="Permalink"></a></h3><p>The <code>Electrum.ByCoordinate{D}</code> supertype contains <code>Electrum.ByCartesianCoordinate{D}</code> and <code>Electrum.ByFractionalCoordinate{D}</code>, corresponding to Cartesian or fractional coordinates in <code>D</code> dimensions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ByCoordinate-geometry" href="#Electrum.ByCoordinate-geometry"><code>Electrum.ByCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByCoordinate &lt;: Electrum.CrystalDataTrait</code></pre><p>Describes the coordinate system associated with data. This includes <code>ByCartesianCoordinate</code> and <code>ByFractionalCoordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ByCartesianCoordinate-geometry" href="#Electrum.ByCartesianCoordinate-geometry"><code>Electrum.ByCartesianCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByCartesianCoordinate &lt;: ByCoordinate</code></pre><p>Trait type for coordinates represented in terms of an implicit orthonormal basis with units of bohr or rad*bohr⁻¹.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ByFractionalCoordinate-geometry" href="#Electrum.ByFractionalCoordinate-geometry"><code>Electrum.ByFractionalCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByFractionalCoordinate &lt;: ByCoordinate</code></pre><p>Trait type for coordinates in <code>D</code> dimensions whose values depend on a choice of basis, usually the basis vectors describing the lattice in which the coordinate is contained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/traits.jl#L149-L154">source</a></section></article><h2 id="Coordinate-vectors"><a class="docs-heading-anchor" href="#Coordinate-vectors">Coordinate vectors</a><a id="Coordinate-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-vectors" title="Permalink"></a></h2><p>The traits above can be incorporated into new coordinate types that wrap a <code>SVector{D,T&lt;:Real}</code>, and retain information about what type of information is being stored by the coordinate.</p><h3 id="CoordinateVector"><a class="docs-heading-anchor" href="#CoordinateVector"><code>CoordinateVector</code></a><a id="CoordinateVector-1"></a><a class="docs-heading-anchor-permalink" href="#CoordinateVector" title="Permalink"></a></h3><p>The <code>CoordinateVector{S,C,D,T}</code> type is the primary data type for working with spatial coordinates. The <code>RealCartesianCoordinate</code>, <code>RealFractionalCoordinate</code>, <code>ReciprocalCartesianCoordinate</code>, and <code>ReciprocalFractionalCoordinate</code> aliases correspond to the four possible combinations of <code>S</code> and <code>C</code> type parameters, and are preferred for interactive use.</p><p>This type behaves almost identically to <code>SVector{D,T}</code>, but forbids nonsenical operations between data types: for instance, adding a <code>RealCartesianCoordinate</code> to a <code>ReciprocalCartesianCoordinate</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.CoordinateVector-geometry" href="#Electrum.CoordinateVector-geometry"><code>Electrum.CoordinateVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoordinateVector{S&lt;:BySpace,C&lt;:ByCoordinate,D,T&lt;:Real} &lt;: StaticVector{D,T}</code></pre><p>Represents a spatial coordinate with space given by trait <code>S</code> and coordinate trait <code>C</code>. Coordinate values must be subtypes of <code>Real</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.RealCartesianCoordinate-geometry" href="#Electrum.RealCartesianCoordinate-geometry"><code>Electrum.RealCartesianCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealCartesianCoordinate{D,T}
(alias for CoordinateVector{Electrum.ByRealSpace,Electrum.ByCartesianCoordinate,D,T})</code></pre><p>Represents a real space Cartesian coordinate. For more information, see <a href="api/geometry.html#Electrum.CoordinateVector"><code>CoordinateVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.RealFractionalCoordinate-geometry" href="#Electrum.RealFractionalCoordinate-geometry"><code>Electrum.RealFractionalCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealFractionalCoordinate{D,T}
(alias for CoordinateVector{Electrum.ByRealSpace,Electrum.ByFractionalCoordinate,D,T})</code></pre><p>Represents a real space fractional coordinate. For more information, see <a href="api/geometry.html#Electrum.CoordinateVector"><code>CoordinateVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ReciprocalCartesianCoordinate-geometry" href="#Electrum.ReciprocalCartesianCoordinate-geometry"><code>Electrum.ReciprocalCartesianCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReciprocalCartesianCoordinate{D,T}
(alias for CoordinateVector{Electrum.ByReciprocalSpace,Electrum.ByCartesianCoordinate,D,T})</code></pre><p>Represents a reciprocal space Cartesian coordinate. For more information, see <a href="api/geometry.html#Electrum.CoordinateVector"><code>CoordinateVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ReciprocalFractionalCoordinate-geometry" href="#Electrum.ReciprocalFractionalCoordinate-geometry"><code>Electrum.ReciprocalFractionalCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReciprocalFractionalCoordinate{D,T}
(alias for CoordinateVector{Electrum.ByReciprocalSpace,Electrum.ByFractionalCoordinate,D,T})</code></pre><p>Represents a reciprocal space fractional coordinate. For more information, see <a href="api/geometry.html#Electrum.CoordinateVector"><code>CoordinateVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L52-L58">source</a></section></article><h3 id="ShiftVector"><a class="docs-heading-anchor" href="#ShiftVector"><code>ShiftVector</code></a><a id="ShiftVector-1"></a><a class="docs-heading-anchor-permalink" href="#ShiftVector" title="Permalink"></a></h3><p>A <code>ShiftVector</code> is almost identical to a <code>CoordinateVector</code>, and wraps one as a field, but includes a weight parameter that defaults to 1.</p><p>The primary use for <code>ShiftVector</code> is to provide information about how data associated with a lattice is shifted with respect to the origin. In particular, it forms the implementation of <code>KPoint{D,T}</code>, which is simply an alias for <code>ShiftVector{ByReciprocalSpace,D,T}</code>. In many cases, lists of k-points are symmetry-reduced, and the weight parameter is used to account for coordinates not present in the list due to symmetry reduction.</p><p>To retain the </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.ShiftVector-geometry" href="#Electrum.ShiftVector-geometry"><code>Electrum.ShiftVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftVector{S&lt;:BySpace,D,T} &lt;: StaticVector{D,T}</code></pre><p>A vector in fractional coordinates representing a shift of a lattice or lattice dataset from the origin. This wraps a <code>CoordinateVector{S,ByFractionalCoordinate,D,T}</code> with an optional weight parameter that may be useful when working with symmetrical structures or k-points in the irreducible Brillouin zone. If it is not explicitly set, it defaults to 1.</p><p>If constructors do not explicitly reference an element type, the element type is automatically inferred by promoting the types of the arguments.</p><p><strong>Type aliases</strong></p><p><code>ShiftVector</code> is a general way of working with vectors which shift a lattice or data within it, and for this reason we define an alias for representing k-points:</p><pre><code class="nohighlight hljs">const KPoint = ShiftVector{ByReciprocalSpace}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L129-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.KPoint-geometry" href="#Electrum.KPoint-geometry"><code>Electrum.KPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KPoint{D,T} (alias for ShiftVector{ByReciprocalSpace,D,T})</code></pre><p>Represents a k-point, or an offset from the Γ point (origin) of reciprocal space, often used in band structures, wavefunctions, or other electronic data.</p><p>For more information about this type, see <a href="api/geometry.html#Electrum.ShiftVector"><code>ShiftVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.weight-geometry" href="#Electrum.weight-geometry"><code>Electrum.weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight(k::ShiftVector{S,D,T}) -&gt; T</code></pre><p>Returns the weight associated with a <code>ShiftVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/vectors.jl#L207-L211">source</a></section></article><h2 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h2><p><code>LatticeBasis{S&lt;:BySpace,D,T} &lt;: StaticMatrix{D,D,T}</code> represents the real or reciprocal space basis vectors of a lattice as a matrix. For convenience, we define <code>RealBasis</code> as an alias for <code>LatticeBasis{ByRealSpace}</code>, and <code>ReciprocalBasis</code> for <code>LatticeBasis{ByReciprocalSpace}</code>.</p><p>The units of <code>RealBasis</code> are bohr, and those of <code>ReciprocalBasis</code> are radians over bohr, corresponding with the convention that the dot product of a real basis vector with a corresponding reciprocal basis vector is 2π.</p><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><p>A <code>RealBasis</code> or <code>ReciprocalBasis</code> can be constructed from an <code>AbstractMatrix</code>, <code>Tuple</code>, or iterator of the correct size.</p><p>In the case of a <code>StaticMatrix</code>, the size and element type are already known, so the constructors can simply be called as <code>RealBasis</code> or <code>ReciprocalBasis</code>:</p><pre><code class="nohighlight hljs">julia&gt; RealBasis(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))
Electrum.LatticeBasis{ByRealSpace, 3, Int64}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><p>However, in the case of a <code>Matrix</code> or other dynamically sized data, the dimension is not known and should be supplied to avoid an exception being thrown. This is to avoid type instability arising from determining the size at runtime:</p><pre><code class="nohighlight hljs">julia&gt; RealBasis{3}([1 0 0; 0 2 0; 0 0 3])
Electrum.LatticeBasis{ByRealSpace, 3, Int64}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><p>In either case, you can supply the element type (though it must be proceeded by the dimension in all cases) to convert the input elements to the desired type (here, it&#39;s <code>Float32</code>):</p><pre><code class="nohighlight hljs">julia&gt; RealBasis{3,Float32}(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))
Electrum.LatticeBasis{ByRealSpace, 3, Float32}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>A <code>RealBasis</code> can be converted to a <code>ReciprocalBasis</code> via <code>convert</code> or their constructors, and vice versa:</p><pre><code class="language-julia hljs">b = ReciprocalBasis(a)
c = convert(RealBasis, b)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Avoid needless back-and-forth conversions between <code>RealBasis</code> and <code>ReciprocalBasis</code> to avoid numerical instabilities.</p></div></div><h3 id="Mathematical-operations"><a class="docs-heading-anchor" href="#Mathematical-operations">Mathematical operations</a><a id="Mathematical-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-operations" title="Permalink"></a></h3><p>The <code>RealBasis</code> and <code>ReciprocalBasis</code> types support the majority of common operations used in  solid-state chemistry, including addition, subtraction, multiplication, left division, and right division. </p><p>Importantly, it supports the QR decomposition provided by <code>LinearAlgebra.qr</code>. This decomposition is useful in that it generates a <span>$Q$</span> factor, which is an orthogonal matrix (representing a Euclidean point isometry - compositions of rotations and reflections) and an <span>$R$</span> factor, which is an upper triangular matrix. This operation is useful in converting lattices to a standard orientation: in the case of a QR decomposition, the <span>$R$</span> factor places the first basis vector of the lattice along the first basis vector of space. In 3D, this means that <span>$\vec{a}$</span> is collinear with <span>$\vec{x}$</span>.</p><p>Calling <code>LinearAlgebra.qr(::LatticeBasis)</code> returns a <code>StaticArrays.QR{SMatrix{D,D,T,D^2}, SMatrix{D,D,T,D^2}, SVector{D,Int}}</code>, so the <span>$Q$</span> and <span>$R$</span> factors are bare <span>$SMatrix$</span> instances. While this is fine for the <span>$Q$</span> matrix, the <span>$R$</span> matrix represents a basis, and we expect an <code>LatticeBasis</code> return value. The <code>triangularize</code> function returns the <span>$R$</span> factor of a QR decomposition as an <code>LatticeBasis</code>, discarding the <span>$Q$</span> factor.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.triangularize-geometry" href="#Electrum.triangularize-geometry"><code>Electrum.triangularize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangularize(l::T) where T&lt;:LatticeBasis -&gt; T</code></pre><p>Converts a set of basis vectors to an upper triangular form using QR decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/lattices.jl#L358-L362">source</a></section><section><div><pre><code class="language-julia hljs">triangularize(l::T, sc::AbstractMatrix{&lt;:Integer}) where T&lt;:LatticeBasis -&gt; T</code></pre><p>Converts a set of basis vectors to an upper triangular form using QR decomposition, with an included conversion to a larger supercell. The resulting matrix that describes the basis vectors will have only positive values along the diagonal, and therefore, is always right-handed (regardless of the transformation matrix used).</p><p>LAMMPS expects that basis vectors are given in this format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/2ec15a10ba8f559349ffc8a9ce37a7a26e38c54c/src/lattices.jl#L368-L377">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Support for the corresponding LQ decomposition (where <span>$L$</span> is a lower triangular matrix) is not yet implemented.</p></div></div><h3 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h3><p>The <code>SMatrix{D1,D2,T,L}</code> type requires four type parameters - <code>D1</code> and <code>D2</code> are each of the matrix dimensions, and <code>T</code> is the element type of the matrix. However, one last parameter is needed: <code>L</code>,  the length of the <code>NTuple</code> that backs the <code>SMatrix</code>.</p><p>Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a problem in the declaration of structs. Technically, a type like <code>SMatrix{3,3,Float64}</code> is an abstract type, as the <code>L</code> parameter is undeclared, even though the value of <code>L</code> is always <code>D1 * D2</code>. By declaring a struct to have this type, there seems to be a performance drop.</p><p>The <code>LatticeBasis</code> types wrap an <code>SVector{D,SVector{D,Float64}}</code>. This only requires a single  type parameter <code>D</code>, and allows for fully concrete struct declarations. The <code>:matrix</code> property converts this data to an <code>SMatrix{D,D,T,D^2}</code> instance, and methods needing to access something that looks like a matrix reference this property.</p><h2 id="Basis-vectors-in-composite-types"><a class="docs-heading-anchor" href="#Basis-vectors-in-composite-types">Basis vectors in composite types</a><a id="Basis-vectors-in-composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-vectors-in-composite-types" title="Permalink"></a></h2><p>Some types (such as <code>Electrum.DataGrid</code>) store a set of basis vectors as part of the dataset. The <code>basis</code> function allows a user to access that set of basis vectors. By default, <code>basis(x)</code> returns <code>x.basis</code>, so defining a field <code>basis::RealBasis{...}</code> or <code>basis::ReciprocalBasis{...}</code> implements these functions automatically.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>basis(x)</code> returns an <code>LatticeBasis</code>, but there is no guarantee whether the return type is <code>RealBasis</code> or <code>ReciprocalBasis</code>. Use <code>convert(::Type{&lt;:LatticeBasis}, basis(x))</code> to ensure that the return type is what you expect.</p></div></div><p>The type of basis vectors stored also allows for inference of the data space trait, as the default definition of <code>DataSpace(::Type{T})</code> is <code>fieldtype(T, :basis)</code>. We encourage you to choose your basis vector type to match the data you wish to represent.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, we encourage you to define struct fields with concrete types, and use  type parameters in your struct definitions to ensure that the type is concrete.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="atoms.html">Atoms and crystals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 12 December 2023 20:12">Tuesday 12 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
