<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattices · Electrum.jl</title><meta name="title" content="Lattices · Electrum.jl"/><meta property="og:title" content="Lattices · Electrum.jl"/><meta property="twitter:title" content="Lattices · Electrum.jl"/><meta name="description" content="Documentation for Electrum.jl."/><meta property="og:description" content="Documentation for Electrum.jl."/><meta property="twitter:description" content="Documentation for Electrum.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Electrum.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="lattices.html">Lattices</a><ul class="internal"><li><a class="tocitem" href="#Real-and-reciprocal-space-traits"><span>Real and reciprocal space traits</span></a></li><li><a class="tocitem" href="#Electrum.LatticeBasis-and-methods"><span><code>Electrum.LatticeBasis</code> and methods</span></a></li><li><a class="tocitem" href="#Basis-vectors-in-composite-types"><span>Basis vectors in composite types</span></a></li></ul></li><li><a class="tocitem" href="atoms.html">Atoms and crystals</a></li><li><a class="tocitem" href="grids.html">Data grids</a></li><li><a class="tocitem" href="filetypes.html">File formats</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/lattices.html">Lattices</a></li><li><a class="tocitem" href="api/atoms.html">Atoms</a></li><li><a class="tocitem" href="api/crystals.html">Crystals</a></li><li><a class="tocitem" href="api/data.html">Crystal data</a></li><li><a class="tocitem" href="api/filetypes.html">File formats</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="lattices.html">Lattices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="lattices.html">Lattices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brainandforce/Electrum.jl/blob/main/docs/src/lattices.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h1><p>The starting point for solid state structures is a periodic lattice. Electrum provides convenient types for working with lattices of arbitrary dimension</p><h2 id="Real-and-reciprocal-space-traits"><a class="docs-heading-anchor" href="#Real-and-reciprocal-space-traits">Real and reciprocal space traits</a><a id="Real-and-reciprocal-space-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Real-and-reciprocal-space-traits" title="Permalink"></a></h2><p>The <code>Electrum.BySpace{D}</code> supertype contains two types, <code>Electrum.ByRealSpace{D}</code> and <code>Electrum.ByReciprocalSpace{D}</code>, where <code>D</code> is the number of dimensions associated with the dataset. These types are used to denote whether data is associated with real space (e.g. electron density) or  reciprocal space (e.g. the Fourier transform of the electron density). When working with lattices, it is important to distinguish the two types of lattice: this is the primary reason why bare <code>SMatrix{D,D,T}</code> instances are not used in this package.</p><h2 id="Electrum.LatticeBasis-and-methods"><a class="docs-heading-anchor" href="#Electrum.LatticeBasis-and-methods"><code>Electrum.LatticeBasis</code> and methods</a><a id="Electrum.LatticeBasis-and-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Electrum.LatticeBasis-and-methods" title="Permalink"></a></h2><p>The <code>Electrum.LatticeBasis{S&lt;:Electrum.BySpace,D,T}</code> data type is a wrapper for an <code>SMatrix{D,D,T,D^2}</code> which represents the real or reciprocal space basis vectors of a lattice.</p><p>Electrum does not export <code>Electrum.LatticeBasis</code>, but instead provide the following aliases. This allows developers to alter the implementation of <code>Electrum.LatticeBasis</code> without breaking the API:</p><pre><code class="language-julia hljs">const RealBasis = Electrum.LatticeBasis{ByRealSpace}
const ReciprocalBasis = Electrum.LatticeBasis{ByReciprocalSpace}
const AbstractBasis = Electrum.LatticeBasis{&lt;:BySpace}</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that <code>RealBasis{D} === Electrum.LatticeBasis{ByRealSpace,D}</code>, and not <code>Electrum.LatticeBasis{ByRealSpace{D},D}</code>. While the latter is a valid type and can be used to store data, the result of <code>Electrum.DataSpace(::Electrum.LatticeBasis{ByRealSpace{D},D})</code> is an error!</p></div></div><p>The units of <code>RealBasis</code> are bohr, and those of <code>ReciprocalBasis</code> are radians over bohr, corresponding with the convention that the dot product of a real basis vector with a corresponding reciprocal basis vector is 2π.</p><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><p>A <code>RealBasis</code> or <code>ReciprocalBasis</code> can be constructed from an <code>AbstractMatrix</code>, <code>Tuple</code>, or iterator of the correct size.</p><p>In the case of a <code>StaticMatrix</code>, the size and element type are already known, so the constructors can simply be called as <code>RealBasis</code> or <code>ReciprocalBasis</code>:</p><pre><code class="nohighlight hljs">julia&gt; RealBasis(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))
Electrum.LatticeBasis{Electrum.ByRealSpace, 3, Int64}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><p>However, in the case of a <code>Matrix</code> or other dynamically sized data, the dimension is not known and should be supplied to avoid an exception being thrown. This is to avoid type instability arising from determining the size at runtime:</p><pre><code class="nohighlight hljs">julia&gt; RealBasis{3}([1 0 0; 0 2 0; 0 0 3])
Electrum.LatticeBasis{Electrum.ByRealSpace, 3, Int64}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><p>In either case, you can supply the element type (though it must be proceeded by the dimension in all cases) to convert the input elements to the desired type (here, it&#39;s <code>Float32</code>):</p><pre><code class="nohighlight hljs">julia&gt; RealBasis{3,Float32}(SMatrix{3,3}(1, 0, 0, 0, 2, 0, 0, 0, 3))
Electrum.LatticeBasis{Electrum.ByRealSpace, 3, Float32}:
    a: [  1.000000   0.000000   0.000000 ]   (1.000000 bohr)
    b: [  0.000000   2.000000   0.000000 ]   (2.000000 bohr)
    c: [  0.000000   0.000000   3.000000 ]   (3.000000 bohr)</code></pre><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>A <code>RealBasis</code> can be converted to a <code>ReciprocalBasis</code> via <code>Base.convert</code> or their constructors, and vice versa:</p><pre><code class="language-julia hljs">b = ReciprocalBasis(a)
c = convert(RealBasis, b)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Avoid needless back-and-forth conversions between <code>RealBasis</code> and <code>ReciprocalBasis</code> to avoid numerical instabilities.</p></div></div><h3 id="Mathematical-operations"><a class="docs-heading-anchor" href="#Mathematical-operations">Mathematical operations</a><a id="Mathematical-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-operations" title="Permalink"></a></h3><p>The <code>RealBasis</code> and <code>ReciprocalBasis</code> types support the majority of common operations used in  solid-state chemistry, including addition, subtraction, multiplication, left division, and right division. </p><p>Importantly, it supports the QR decomposition provided by <code>LinearAlgebra.qr</code>. This decomposition is useful in that it generates a <code>Q</code><code>factor, which is an orthogonal matrix (representing a Euclidean point isometry - compositions of rotations and reflections) and an</code><code>R</code><code>factor, which is an upper triangular matrix. This operation is useful in converting lattices to a standard orientation: in the case of a QR decomposition, the $R$ factor places the first basis vector of the lattice along the first basis vector of space. In 3D, this means that</code><code>\vec{a}</code><code>is collinear with</code><code>\vec{x}</code>`.</p><p>Calling <code>LinearAlgebra.qr(::AbstractBasis{D,T})</code> returns a <code>StaticArrays.QR{SMatrix{D,D,T,D^2}, SMatrix{D,D,T,D^2}, SVector{D,Int}}</code>, so the <span>$Q$</span> and <span>$R$</span> factors are bare <span>$SMatrix$</span> instances. While this is fine for the <span>$Q$</span> matrix, the <span>$R$</span> matrix represents a basis, and we expect an <code>AbstractBasis</code> return value. The <code>triangularize</code> function returns the <span>$R$</span> factor of a QR decomposition as an <code>AbstractBasis</code>, discarding the <span>$Q$</span> factor.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Electrum.triangularize-lattices" href="#Electrum.triangularize-lattices"><code>Electrum.triangularize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangularize(l::T) where T&lt;:LatticeBasis -&gt; T</code></pre><p>Converts a set of basis vectors to an upper triangular form using QR decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/fdeab2aaf11e5ccaa37a651d111eadfe4f43e673/src/lattices.jl#L340-L344">source</a></section><section><div><pre><code class="language-julia hljs">triangularize(l::T, sc::AbstractMatrix{&lt;:Integer}) where T&lt;:LatticeBasis -&gt; T</code></pre><p>Converts a set of basis vectors to an upper triangular form using QR decomposition, with an included conversion to a larger supercell. The resulting matrix that describes the basis vectors will have only positive values along the diagonal, and therefore, is always right-handed (regardless of the transformation matrix used).</p><p>LAMMPS expects that basis vectors are given in this format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/Electrum.jl/blob/fdeab2aaf11e5ccaa37a651d111eadfe4f43e673/src/lattices.jl#L350-L359">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Support for the corresponding LQ decomposition (where <span>$L$</span> is a lower triangular matrix) is not yet implemented.</p></div></div><h3 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h3><p>The <code>SMatrix{D1,D2,T,L}</code> type requires four type parameters - <code>D1</code> and <code>D2</code> are each of the matrix dimensions, and <code>T</code> is the element type of the matrix. However, one last parameter is needed: <code>L</code>,  the length of the <code>NTuple</code> that backs the <code>SMatrix</code>.</p><p>Julia currently does not allow for the calculation of type parameters from other type parameters, which poses a problem in the declaration of structs. Technically, a type like <code>SMatrix{3,3,Float64}</code> is an abstract type, as the <code>L</code> parameter is undeclared, even though the value of <code>L</code> is always <code>D1 * D2</code>. By declaring a struct to have this type, there seems to be a performance drop.</p><p>The <code>LatticeBasis</code> types wrap an <code>SVector{D,SVector{D,Float64}}</code>. This only requires a single  type parameter <code>D</code>, and allows for fully concrete struct declarations. The <code>:matrix</code> property converts this data to an <code>SMatrix{D,D,T,D^2}</code> instance, and methods needing to access something that looks like a matrix reference this property.</p><h2 id="Basis-vectors-in-composite-types"><a class="docs-heading-anchor" href="#Basis-vectors-in-composite-types">Basis vectors in composite types</a><a id="Basis-vectors-in-composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-vectors-in-composite-types" title="Permalink"></a></h2><p>Some types (such as <code>Electrum.DataGrid</code>) store a set of basis vectors as part of the dataset. The <code>basis</code> function allows a user to access that set of basis vectors. By default, <code>basis(x)</code> returns <code>x.basis</code>, so defining a field <code>basis::RealBasis{...}</code> or <code>basis::ReciprocalBasis{...}</code> implements these functions automatically.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>basis(x)</code> returns an <code>AbstractBasis</code>, but there is no guarantee whether the return type is <code>RealBasis</code> or <code>ReciprocalBasis</code>. Use <code>convert(::Type{&lt;:AbstractBasis}, basis(x))</code> to ensure that the return type is what you expect.</p></div></div><p>The type of basis vectors stored also allows for inference of the data space trait, as the default definition of <code>DataSpace(::Type{T})</code> is <code>fieldtype(T, :basis)</code>. We encourage you to choose your basis vector type to match the data you wish to represent.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, we encourage you to define struct fields with concrete types, and use  type parameters in your struct definitions to ensure that the type is concrete.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="atoms.html">Atoms and crystals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Saturday 18 November 2023 23:55">Saturday 18 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
