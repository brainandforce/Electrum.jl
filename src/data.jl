"""
    RealSpaceDataGrid{D,T} <: AbstractRealSpaceData{D}

A data grid defined in real space, containing data of type T.
"""
struct RealSpaceDataGrid{D,T} <: AbstractRealSpaceData{D}
    # Basis vectors defining the lattice
    latt::SMatrix{D,D,Float64}
    # The actual data grid
    grid::Array{T,D}
    # Inner constructor
    function RealSpaceDataGrid{D,T}(
        latt::AbstractMatrix{<:Real},
        grid::AbstractArray{T,D}
    ) where {D,T}
        # Still gotta pass the lattice sanity checks
        lattice_sanity_check(latt)
        return new(latt, grid)
    end
end

"""
    RealSpaceDataGrid{D,T}(latt::AbstractLattice{D}, grid::AbstractArray{T,D}; prim=true)

Creates a real space data grid using lattice information from an `AbstractLattice`. By default,
data is assumed to be given in terms of the primitive lattice (as is usually the case for
computational data).
"""
function RealSpaceDataGrid{D,T}(
    latt::AbstractLattice{D},
    grid::AbstractArray{T,D};
    prim=true
) where {D,T}
    # Conversion for safety
    l = RealLattice{D}(latt)
    if prim
        return RealSpaceDataGrid{D,T}(l.prim, grid)
    else
        return RealSpaceDataGrid{D,T}(l.conv, grid)
    end
end

# Data in RealSpaceDataGrids can now be indexed
Base.getindex(g::RealSpaceDataGrid{D,T} where {D,T}, inds...) = getindex(g.grid, inds...)

# Size of the data grid
# TODO: should we overload Base.size() as well?
gridsize(g::RealSpaceDataGrid{D,T} where {D,T}) = size(g.grid)
Base.size(g::RealSpaceDataGrid{D,T} where {D,T}) = gridsize(g)

# TODO: Make mathematical operations on RealSpaceDataGrids easy

"""
    KPointGrid{D} <: AbstractKPoints{D}

Contains a grid used to generate k-points during a calculation.

The grid itself is given as an `SMatrix{D,D,Int}`, and can be interpreted as a set of `D` vectors 
given in terms of the primitive basis. These vectors can alternatively be used to construct a 
supercell.

The shift of the k-point mesh off Î“ is given as an `SVector{D,Float64}`.
"""
struct KPointGrid{D} <: AbstractKPoints{D}
    grid::SMatrix{D,D,Int}
    orig::SVector{D,Float64}
    function KPointGrid{D}(grid::AbstractMatrix{<:Integer}, orig::AbstractVector{<:Real}) where D
        # only allow positive values in the grid matrix
        @assert all(x -> x > 0, grid) "negative values are disallowed in the grid matrix"
        # Keep shift inside the Brillouin zone
        orig = orig -  round.(orig)
        return new(grid, orig)
    end
end

"""
    KPointList{D} <: AbstractKPoints{D}

Contains a list of k-points. This is useful for describing k-points that are not associated with 
a mesh - for instance, those used in band structure calculations. This can also be used to store
lists of k-points that are generated by a `KPointGrid{D}`.
"""
struct KPointList{D} <: AbstractKPoints{D}
    list::Vector{SVector{D,Float64}}
    function KPointList{D}(list::AbstractVector{<:AbstractVector{<:Real}}) where D
        # TODO: we should probably remove any points that are outside of the Brillouin zone
        return new(list)
    end
end

"""
    ReciprocalWavefunction{D,T} <: AbstractReciprocalSpaceData{D}

Contains a wavefunction stored by k-points and bands in a planewave basis. Used to store data in
VASP WAVECAR files.

For every k-point, there is an associated number of bands (the same number for every k-point). Band
information is stored as the energy of the band and its occupancy.

Every band has associated data containing coefficients of the constituent planewaves.
"""
struct ReciprocalWavefunction{D,T} <: AbstractReciprocalSpaceData{D}
    # List of k-points used
    kptlist::KPointList{D}
    # Bands (energy and occupation)
    # Vector (size nkpt) of Vectors (size nband) of Tuples
    bands::Vector{Vector{NTuple{2,T}}}
    # Planewave coefficients
    # Vector (size nkpt) of Vectors (size nband) of Vectors (size npw)
    waves::Vector{Vector{Vector{T}}}
    function ReciprocalWavefunction{D,T}(
        kptlist::KPointList{D},
        bands::AbstractVector{AbstractVector{NTuple{2,<:Real}}},
        waves::AbstractVector{AbstractVector{AbstractVector{<:Real}}}
    ) where {D,T<:Real}
        return new(kptlist, bands, waves)
    end
end

function ReciprocalWavefunction{D,T}(
    kptlist::AbstractVector{<:AbstractVector{<:Real}},
    bands::AbstractVector{AbstractVector{NTuple{2,<:Real}}},
    waves::AbstractVector{AbstractVector{AbstractVector{<:Real}}}  
) where {D,T<:Real}
    return ReciprocalWavefunction{D,T}(KPointList{D}(kptlist), bands, waves)
end