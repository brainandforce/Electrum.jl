"""
    basis_string(M::AbstractMatrix{<:Real}; letters=true) -> Vector{String}

Prints each basis vector with an associated letter.
"""
function basis_string(
    M::AbstractMatrix{<:Real};
    pad="  ",
    brackets=true,
    letters=true,
    length=true
)
    # Format the numbers within a vector
    tostr(x, n) = lpad(@sprintf("%f", x), n)
    # Letters are generated by incrementing up from character 0x60
    # Char(0x61) = 'a', Char(0x62) = 'b'...
    # Letters should work up to 26 dimensions, but who's gonna deal with 26D crystals?
    # Bosonic string theorists, maybe?
    return [
                pad * string(Char(0x60 + n), ':', ' ')^letters *
                "["^brackets *
                join(tostr.(M[:,n], 11)) *
                "  ]"^brackets * 
                ("   (" * tostr(norm(M[:,n]), 0))^length * ")"
                for n in 1:size(M)[2]
            ]
end

function printbasis(io::IO, M::AbstractMatrix{<:Real}, letters=true)
    println(io, "Basis vectors:")
    println.(io, basis_string(M), letters=letters)
    return nothing
end

printbasis(io::IO, a::AtomList; letters=true) = printbasis(io, a.basis, letters=letters)
printbasis(io::IO, g::RealSpaceDataGrid{D,T} where {D,T}; letters=true) =
    printbasis(io, g.basis, letters=letters)

function atom_string(a::AtomPosition; name=true, num=true)
    # Format the numbers within a vector
    tostr(x) = lpad(@sprintf("%f", x), 12)
    return rpad(string(a.num), 4)^num * rpad(a.name, 4)^name * join(tostr.(a.pos))
end

function Base.show(io::IO, ::MIME"text/plain", a::AtomPosition; name=true, num=true)
    print(typeof(a), ":")
    print(io, atom_string(a, name=name, num=num))
end

function Base.show(io::IO, ::MIME"text/plain", a::AtomList; name=true, num=true, letters=true)
    # Print type name
    println(io, typeof(a), ":")
    # Print basis vectors
    printbasis(io, a.basis)
    # Print atomic positions
    println(io, "Atomic positions:")
    println.(io, atom_string.(a.coord, name=name, num=num))
end

#=
function Base.show(io::IO, ::MIME"text/plain", g::RealSpaceDataGrid{D,T} where {D,T})
    println(io, typeof(g), ':')
    # Print basis vectors
    println(io, "Basis vectors:")
    println.(io, basis_string(g.basis))
end
=#

function Base.show(io::IO, ::MIME"text/plain", wf::ReciprocalWavefunction{D,T}) where {D,T}
    println(io,
        typeof(wf), " with ", string(nkpt(wf)), " k-points and ", string(nband(wf)), " bands")
end

function Base.show(io::IO, ::MIME"text/plain", g::RealSpaceDataGrid{D,T}) where {D,T}
    dimstring = join(string.(size(g)), "Ã—") * " "
    println(io, dimstring, typeof(g), " with basis vectors:")
    print(join(basis_string(g.latt), "\n"))
    vol = abs(det(g.latt))
    println("\nCell volume: ", vol)
    print("Voxel size: ", vol / prod(size(g)))
end