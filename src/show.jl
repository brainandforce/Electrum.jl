"""
    basis_string(M::AbstractMatrix{<:Real}; letters=true) -> Vector{String}

Prints each basis vector with an associated letter.
"""
function basis_string(M::AbstractMatrix{<:Real}; letters=true)
    # Format the numbers within a vector
    tostr(x) = lpad(@sprintf("%f", x), 12)
    # Letters are generated by incrementing up from character 0x60
    # Char(0x61) = 'a', Char(0x62) = 'b'...
    # Letters should work up to 26 dimensions, but who's gonna deal with 26D crystals?
    # Bosonic string theorists, maybe?
    return [string(Char(0x60 + n), ':', ' ')^letters * join(tostr.(M[:,n])) for n in 1:size(M)[2]]
end

function printbasis(io::IO, M::AbstractMatrix{<:Real}, letters=true)
    println(io, "Basis vectors:")
    println.(io, basis_string(M), letters=letters)
    return nothing
end

printbasis(io::IO, a::AtomList; letters=true) = printbasis(io, a.basis, letters=letters)
printbasis(io::IO, g::RealSpaceDataGrid{D,T} where {D,T}; letters=true) =
    printbasis(io, g.basis, letters=letters)

function atom_string(a::AtomPosition; name=true, num=true)
    # Format the numbers within a vector
    tostr(x) = lpad(@sprintf("%f", x), 12)
    return rpad(string(a.num), 4)^num * rpad(a.name, 4)^name * join(tostr.(a.pos))
end

function Base.show(io::IO, ::MIME"text/plain", a::AtomPosition; name=true, num=true)
    print(typeof(a), ":")
    print(io, atom_string(a, name=name, num=num))
end

function Base.show(io::IO, ::MIME"text/plain", a::AtomList; name=true, num=true, letters=true)
    # Print type name
    println(io, typeof(a), ":")
    # Print basis vectors
    printbasis(io, a.basis)
    # Print atomic positions
    println(io, "Atomic positions:")
    println.(io, atom_string.(a.coord, name=name, num=num))
end

function Base.show(io::IO, ::MIME"text/plain", g::RealSpaceDataGrid{D,T} where {D,T})
    println(io, typeof(g), ':')
    # Print basis vectors
    println(io, "Basis vectors:")
    println.(io, basis_string(a.basis))
end